# 第5章 オブジェクト指向設計の真髄

オブジェクト指向設計の核心は、SOLID原則に代表される設計原則の理解と適用である。本章では、これらの原則を深く理解し、実践的な設計スキルを身につける。

![SOLID原則の構造図](Images/solid-principles-diagram.md)

## 5.1 単一責務原則の深い理解

### 5.1.1 単一責務原則(SRP)の本質

Robert C. Martin(Uncle Bob)が提唱したSOLID原則の最初の原則である単一責務原則(Single Responsibility Principle)は、オブジェクト指向設計の根幹を成す重要な概念である。

> 「クラスが変更される理由は一つでなければならない」

しかし、この定義は表面的な理解にとどまりがちである。より深い理解のためには、**責務(Responsibility)**の概念を正しく把握する必要がある。

### 5.1.2 責務の定義と識別

#### 責務とは何か

責務とは、**システム内の特定のアクター(利害関係者)に対する義務**である。アクターとは、システムの変更を要求する人々やプロセスのグループを指す。

```csharp
// 複数のアクターに対する責務が混在している例(SRP違反)
public class Employee
{
    public string Name { get; set; }
    public decimal BaseSalary { get; set; }
    public string Department { get; set; }
    
    // アクター1: 人事部門(給与計算)
    public decimal CalculateOvertimePay(int overtimeHours)
    {
        return BaseSalary / 160 * 1.5m * overtimeHours;
    }
    
    // アクター2: 経理部門(会計処理)
    public void SaveToDatabase()
    {
        using var connection = new SqlConnection(connectionString);
        var command = new SqlCommand(
            "INSERT INTO Employees (Name, BaseSalary, Department) VALUES (@name, @salary, @dept)", 
            connection);
        command.Parameters.AddWithValue("@name", Name);
        command.Parameters.AddWithValue("@salary", BaseSalary);
        command.Parameters.AddWithValue("@dept", Department);
        command.ExecuteNonQuery();
    }
    
    // アクター3: ITオペレーション(レポート生成)
    public string GenerateReport()
    {
        return $"Employee Report\n" +
               $"Name: {Name}\n" +
               $"Department: {Department}\n" +
               $"Base Salary: {BaseSalary:C}";
    }
}
```

この設計の問題点:
- **人事部門**が給与計算ルールを変更したい
- **経理部門**がデータベーススキーマを変更したい  
- **ITオペレーション**がレポート形式を変更したい

これらの変更は互いに無関係だが、すべて同じクラスに影響を与える。

#### SRPに従った設計

```csharp
// 責務を分離した設計
public class Employee  // 純粋なデータ表現
{
    public int Id { get; }
    public string Name { get; }
    public decimal BaseSalary { get; }
    public string Department { get; }
    
    public Employee(int id, string name, decimal baseSalary, string department)
    {
        Id = id;
        Name = name;
        BaseSalary = baseSalary;
        Department = department;
    }
}

// アクター1: 人事部門の責務
public class PayrollCalculator
{
    public decimal CalculateOvertimePay(Employee employee, int overtimeHours)
    {
        var hourlyRate = employee.BaseSalary / 160;
        var overtimeRate = hourlyRate * 1.5m;
        return overtimeRate * overtimeHours;
    }
    
    public decimal CalculateTotalPay(Employee employee, int overtimeHours)
    {
        return employee.BaseSalary + CalculateOvertimePay(employee, overtimeHours);
    }
}

// アクター2: 経理部門の責務
public class EmployeeRepository
{
    private readonly string _connectionString;
    
    public EmployeeRepository(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public async Task SaveAsync(Employee employee)
    {
        using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync();
        
        var command = new SqlCommand(
            "INSERT INTO Employees (Id, Name, BaseSalary, Department) VALUES (@id, @name, @salary, @dept)", 
            connection);
        command.Parameters.AddWithValue("@id", employee.Id);
        command.Parameters.AddWithValue("@name", employee.Name);
        command.Parameters.AddWithValue("@salary", employee.BaseSalary);
        command.Parameters.AddWithValue("@dept", employee.Department);
        
        await command.ExecuteNonQueryAsync();
    }
    
    public async Task<Employee> FindByIdAsync(int id)
    {
        using var connection = new SqlConnection(_connectionString);
        await connection.OpenAsync();
        
        var command = new SqlCommand("SELECT * FROM Employees WHERE Id = @id", connection);
        command.Parameters.AddWithValue("@id", id);
        
        using var reader = await command.ExecuteReaderAsync();
        if (await reader.ReadAsync())
        {
            return new Employee(
                reader.GetInt32("Id"),
                reader.GetString("Name"),
                reader.GetDecimal("BaseSalary"),
                reader.GetString("Department"));
        }
        
        return null;
    }
}

// アクター3: ITオペレーションの責務
public class EmployeeReportGenerator
{
    public string GenerateDetailedReport(Employee employee)
    {
        return $"=== Employee Report ===\n" +
               $"ID: {employee.Id}\n" +
               $"Name: {employee.Name}\n" +
               $"Department: {employee.Department}\n" +
               $"Base Salary: {employee.BaseSalary:C}\n" +
               $"Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}";
    }
    
    public string GenerateSummaryReport(IEnumerable<Employee> employees)
    {
        var summary = employees
            .GroupBy(e => e.Department)
            .Select(g => new 
            {
                Department = g.Key,
                Count = g.Count(),
                AverageSalary = g.Average(e => e.BaseSalary),
                TotalSalary = g.Sum(e => e.BaseSalary)
            });
            
        var report = "=== Department Summary ===\n";
        foreach (var dept in summary)
        {
            report += $"{dept.Department}: {dept.Count} employees, " +
                     $"Avg: {dept.AverageSalary:C}, Total: {dept.TotalSalary:C}\n";
        }
        
        return report;
    }
}
```

### 5.1.3 責務の粒度

#### 適切な責務レベルの判断

責務の粒度は文脈に依存する。重要なのは、**変更の理由**に着目することである。

```csharp
// 粒度が細かすぎる例
public class CustomerName
{
    public string FirstName { get; }
    public string LastName { get; }
    
    public CustomerName(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
}

public class CustomerEmail
{
    public string Value { get; }
    
    public CustomerEmail(string email)
    {
        if (!IsValidEmail(email))
            throw new ArgumentException("Invalid email format");
        Value = email;
    }
    
    private static bool IsValidEmail(string email) => 
        System.Text.RegularExpressions.Regex.IsMatch(email, @"^[^@\s]+@[^@\s]+\.[^@\s]+$");
}

public class CustomerAddress
{
    public string Street { get; }
    public string City { get; }
    public string PostalCode { get; }
    
    public CustomerAddress(string street, string city, string postalCode)
    {
        Street = street;
        City = city;
        PostalCode = postalCode;
    }
}
```

```csharp
// 適切な粒度の例
public class Customer
{
    public CustomerId Id { get; }
    public CustomerName Name { get; }
    public CustomerEmail Email { get; }
    public CustomerAddress Address { get; }
    public CustomerStatus Status { get; private set; }
    
    public Customer(CustomerId id, CustomerName name, CustomerEmail email, CustomerAddress address)
    {
        Id = id;
        Name = name;
        Email = email;
        Address = address;
        Status = CustomerStatus.Active;
    }
    
    // 顧客ドメインの責務:ステータス管理
    public void Deactivate(DeactivationReason reason)
    {
        if (Status == CustomerStatus.Inactive)
            throw new InvalidOperationException("Customer is already inactive");
            
        Status = CustomerStatus.Inactive;
        DomainEvents.Raise(new CustomerDeactivatedEvent(Id, reason));
    }
    
    public void Reactivate()
    {
        if (Status == CustomerStatus.Active)
            throw new InvalidOperationException("Customer is already active");
            
        Status = CustomerStatus.Active;
        DomainEvents.Raise(new CustomerReactivatedEvent(Id));
    }
}
```

### 5.1.4 コヘージョン(結束度)とカップリング(結合度)

#### 高いコヘージョンの実現

高いコヘージョンとは、クラス内の要素が密接に関連し、共通の目的を持つことである。

```csharp
// 高いコヘージョンの例
public class PriceCalculator
{
    private readonly ITaxService _taxService;
    private readonly IDiscountService _discountService;
    
    public PriceCalculator(ITaxService taxService, IDiscountService discountService)
    {
        _taxService = taxService;
        _discountService = discountService;
    }
    
    // すべてのメソッドが価格計算という共通目的を持つ
    public Money CalculateSubtotal(IEnumerable<OrderItem> items)
    {
        return items
            .Select(item => item.UnitPrice.Multiply(item.Quantity))
            .Aggregate(Money.Zero, (sum, itemTotal) => sum.Add(itemTotal));
    }
    
    public Money CalculateDiscount(Money subtotal, Customer customer)
    {
        return _discountService.CalculateDiscount(subtotal, customer);
    }
    
    public Money CalculateTax(Money subtotal, TaxAddress address)
    {
        return _taxService.CalculateTax(subtotal, address);
    }
    
    public Money CalculateTotal(IEnumerable<OrderItem> items, Customer customer, TaxAddress address)
    {
        var subtotal = CalculateSubtotal(items);
        var discount = CalculateDiscount(subtotal, customer);
        var taxableAmount = subtotal.Subtract(discount);
        var tax = CalculateTax(taxableAmount, address);
        
        return taxableAmount.Add(tax);
    }
}
```

#### 低いカップリングの実現

```csharp
// 疎結合な設計:インターフェースによる抽象化
public interface INotificationService
{
    Task SendAsync(NotificationRequest request);
}

public interface IEmailTemplateService
{
    EmailTemplate GetTemplate(string templateName);
}

public class EmailNotificationService : INotificationService
{
    private readonly IEmailClient _emailClient;
    private readonly IEmailTemplateService _templateService;
    private readonly ILogger<EmailNotificationService> _logger;
    
    public EmailNotificationService(
        IEmailClient emailClient,
        IEmailTemplateService templateService,
        ILogger<EmailNotificationService> logger)
    {
        _emailClient = emailClient;
        _templateService = templateService;
        _logger = logger;
    }
    
    public async Task SendAsync(NotificationRequest request)
    {
        try
        {
            var template = _templateService.GetTemplate(request.TemplateName);
            var email = template.Create(request.Data);
            
            await _emailClient.SendAsync(new EmailMessage
            {
                To = request.Recipient,
                Subject = email.Subject,
                Body = email.Body,
                IsHtml = email.IsHtml
            });
            
            _logger.LogInformation("Email notification sent to {Recipient}", request.Recipient);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send email notification to {Recipient}", request.Recipient);
            throw;
        }
    }
}
```

## 5.2 カプセル化と情報隠蔽

### 5.2.1 カプセル化の真の意味

カプセル化は単にフィールドをprivateにすることではない。それは**データと振る舞いを一つのユニットにまとめ、内部実装を外部から隠蔽する**ことである。

#### データ中心設計の問題

```csharp
// アンチパターン:データ中心設計
public class Order
{
    public List<OrderItem> Items { get; set; } = new();
    public decimal Subtotal { get; set; }
    public decimal Tax { get; set; }
    public decimal Total { get; set; }
    public OrderStatus Status { get; set; }
}

// 外部でビジネスロジックを実装(問題のある設計)
public class OrderService
{
    public void AddItem(Order order, Product product, int quantity)
    {
        var item = new OrderItem 
        { 
            ProductId = product.Id, 
            UnitPrice = product.Price, 
            Quantity = quantity 
        };
        order.Items.Add(item);
        
        // ビジネスロジックが外部に散らばる
        order.Subtotal = order.Items.Sum(i => i.UnitPrice * i.Quantity);
        order.Tax = order.Subtotal * 0.1m;
        order.Total = order.Subtotal + order.Tax;
    }
    
    public void RemoveItem(Order order, int productId)
    {
        var item = order.Items.FirstOrDefault(i => i.ProductId == productId);
        if (item != null)
        {
            order.Items.Remove(item);
            // 再計算も外部で実行
            order.Subtotal = order.Items.Sum(i => i.UnitPrice * i.Quantity);
            order.Tax = order.Subtotal * 0.1m;
            order.Total = order.Subtotal + order.Tax;
        }
    }
}
```

#### 振る舞い中心設計

```csharp
// 改善された設計:カプセル化されたOrder
public class Order
{
    private readonly List<OrderItem> _items = new();
    private OrderStatus _status = OrderStatus.Draft;
    
    public OrderId Id { get; }
    public CustomerId CustomerId { get; }
    public DateTime CreatedDate { get; }
    public IReadOnlyList<OrderItem> Items => _items.AsReadOnly();
    public OrderStatus Status => _status;
    
    // 計算されたプロパティ:一貫性を保証
    public Money Subtotal => _items
        .Select(item => item.LineTotal)
        .Aggregate(Money.Zero, (sum, lineTotal) => sum.Add(lineTotal));
    
    public Money Tax => Subtotal.Multiply(0.1m);
    public Money Total => Subtotal.Add(Tax);
    
    public Order(OrderId id, CustomerId customerId)
    {
        Id = id;
        CustomerId = customerId;
        CreatedDate = DateTime.UtcNow;
    }
    
    // ビジネスルールを内包した振る舞い
    public void AddItem(Product product, int quantity)
    {
        if (_status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify confirmed order");
            
        if (quantity <= 0)
            throw new ArgumentException("Quantity must be positive", nameof(quantity));
            
        var existingItem = _items.FirstOrDefault(item => item.ProductId == product.Id);
        if (existingItem != null)
        {
            existingItem.UpdateQuantity(existingItem.Quantity + quantity);
        }
        else
        {
            _items.Add(new OrderItem(product.Id, product.Name, product.Price, quantity));
        }
        
        DomainEvents.Raise(new ItemAddedToOrderEvent(Id, product.Id, quantity));
    }
    
    public void RemoveItem(ProductId productId)
    {
        if (_status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify confirmed order");
            
        var item = _items.FirstOrDefault(i => i.ProductId == productId);
        if (item != null)
        {
            _items.Remove(item);
            DomainEvents.Raise(new ItemRemovedFromOrderEvent(Id, productId));
        }
    }
    
    public void Confirm()
    {
        if (!_items.Any())
            throw new InvalidOperationException("Cannot confirm empty order");
            
        if (_status != OrderStatus.Draft)
            throw new InvalidOperationException("Order is already confirmed");
            
        _status = OrderStatus.Confirmed;
        DomainEvents.Raise(new OrderConfirmedEvent(Id, Total));
    }
}

// OrderItemも適切にカプセル化
public class OrderItem
{
    public ProductId ProductId { get; }
    public string ProductName { get; }
    public Money UnitPrice { get; }
    public int Quantity { get; private set; }
    
    public Money LineTotal => UnitPrice.Multiply(Quantity);
    
    public OrderItem(ProductId productId, string productName, Money unitPrice, int quantity)
    {
        ProductId = productId;
        ProductName = productName;
        UnitPrice = unitPrice;
        Quantity = quantity;
    }
    
    public void UpdateQuantity(int newQuantity)
    {
        if (newQuantity <= 0)
            throw new ArgumentException("Quantity must be positive", nameof(newQuantity));
            
        Quantity = newQuantity;
    }
}
```

### 5.2.2 不変性(Immutability)の活用

#### 不変オブジェクトの利点

```csharp
// 不変な値オブジェクト
public record Money(decimal Amount, Currency Currency)
{
    public static readonly Money Zero = new(0, Currency.USD);
    
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
        return new Money(Amount + other.Amount, Currency);
    }
    
    public Money Subtract(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot subtract different currencies");
        return new Money(Amount - other.Amount, Currency);
    }
    
    public Money Multiply(decimal multiplier)
    {
        return new Money(Amount * multiplier, Currency);
    }
    
    public Money Divide(decimal divisor)
    {
        if (divisor == 0)
            throw new DivideByZeroException();
        return new Money(Amount / divisor, Currency);
    }
    
    public static implicit operator decimal(Money money) => money.Amount;
    public static explicit operator Money(decimal amount) => new(amount, Currency.USD);
}

public enum Currency
{
    USD, EUR, JPY, GBP
}
```

#### Builder パターンによる複雑な不変オブジェクトの構築

```csharp
// 複雑な不変オブジェクト
public record CustomerProfile
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
    public EmailAddress Email { get; init; }
    public Address Address { get; init; }
    public PhoneNumber PhoneNumber { get; init; }
    public DateTime DateOfBirth { get; init; }
    public CustomerPreferences Preferences { get; init; }
    
    public string FullName => $"{FirstName} {LastName}";
    public int Age => DateTime.Today.Year - DateOfBirth.Year;
}

// Builder パターンで段階的に構築
public class CustomerProfileBuilder
{
    private string _firstName;
    private string _lastName;
    private EmailAddress _email;
    private Address _address;
    private PhoneNumber _phoneNumber;
    private DateTime _dateOfBirth;
    private CustomerPreferences _preferences = CustomerPreferences.Default;
    
    public CustomerProfileBuilder WithName(string firstName, string lastName)
    {
        _firstName = firstName;
        _lastName = lastName;
        return this;
    }
    
    public CustomerProfileBuilder WithEmail(string email)
    {
        _email = new EmailAddress(email);
        return this;
    }
    
    public CustomerProfileBuilder WithAddress(Address address)
    {
        _address = address;
        return this;
    }
    
    public CustomerProfileBuilder WithPhoneNumber(string phoneNumber)
    {
        _phoneNumber = new PhoneNumber(phoneNumber);
        return this;
    }
    
    public CustomerProfileBuilder WithDateOfBirth(DateTime dateOfBirth)
    {
        _dateOfBirth = dateOfBirth;
        return this;
    }
    
    public CustomerProfileBuilder WithPreferences(CustomerPreferences preferences)
    {
        _preferences = preferences;
        return this;
    }
    
    public CustomerProfile Build()
    {
        ValidateRequiredFields();
        
        return new CustomerProfile
        {
            FirstName = _firstName,
            LastName = _lastName,
            Email = _email,
            Address = _address,
            PhoneNumber = _phoneNumber,
            DateOfBirth = _dateOfBirth,
            Preferences = _preferences
        };
    }
    
    private void ValidateRequiredFields()
    {
        var errors = new List<string>();
        
        if (string.IsNullOrWhiteSpace(_firstName))
            errors.Add("First name is required");
        if (string.IsNullOrWhiteSpace(_lastName))
            errors.Add("Last name is required");
        if (_email == null)
            errors.Add("Email is required");
        if (_dateOfBirth == default)
            errors.Add("Date of birth is required");
            
        if (errors.Any())
            throw new InvalidOperationException($"Invalid customer profile: {string.Join(", ", errors)}");
    }
}

// 使用例
var customer = new CustomerProfileBuilder()
    .WithName("John", "Doe")
    .WithEmail("john.doe@example.com")
    .WithDateOfBirth(new DateTime(1985, 3, 15))
    .WithAddress(new Address("123 Main St", "Anytown", "12345"))
    .WithPhoneNumber("+1-555-123-4567")
    .Build();
```

## 5.3 継承と委譲の適切な使い分け

### 5.3.1 継承の適切な使用場面

#### 「is-a」関係の実装

```csharp
// 適切な継承の例:明確な「is-a」関係
public abstract class Vehicle
{
    public string Make { get; }
    public string Model { get; }
    public int Year { get; }
    public VehicleStatus Status { get; protected set; }
    
    protected Vehicle(string make, string model, int year)
    {
        Make = make;
        Model = model;
        Year = year;
        Status = VehicleStatus.Parked;
    }
    
    public virtual void Start()
    {
        if (Status != VehicleStatus.Parked)
            throw new InvalidOperationException($"Cannot start vehicle in {Status} status");
            
        Status = VehicleStatus.Running;
        OnEngineStarted();
    }
    
    public virtual void Stop()
    {
        if (Status != VehicleStatus.Running)
            throw new InvalidOperationException($"Cannot stop vehicle in {Status} status");
            
        Status = VehicleStatus.Parked;
        OnEngineStopped();
    }
    
    protected abstract void OnEngineStarted();
    protected abstract void OnEngineStopped();
    
    public abstract FuelConsumption CalculateFuelConsumption(Distance distance);
}

// 具体的な実装:「Car is a Vehicle」
public class Car : Vehicle
{
    public Engine Engine { get; }
    public FuelType FuelType { get; }
    
    public Car(string make, string model, int year, Engine engine, FuelType fuelType) 
        : base(make, model, year)
    {
        Engine = engine;
        FuelType = fuelType;
    }
    
    protected override void OnEngineStarted()
    {
        Console.WriteLine($"{Make} {Model}: Engine started with {Engine.Displacement}L {FuelType} engine");
    }
    
    protected override void OnEngineStopped()
    {
        Console.WriteLine($"{Make} {Model}: Engine stopped");
    }
    
    public override FuelConsumption CalculateFuelConsumption(Distance distance)
    {
        var efficiency = Engine.CalculateEfficiency(FuelType);
        return new FuelConsumption(distance.Kilometers / efficiency, FuelType);
    }
    
    // Car固有の振る舞い
    public void OpenTrunk()
    {
        Console.WriteLine("Trunk opened");
    }
}

// 別の実装:「Motorcycle is a Vehicle」
public class Motorcycle : Vehicle
{
    public int EngineSize { get; }
    
    public Motorcycle(string make, string model, int year, int engineSize) 
        : base(make, model, year)
    {
        EngineSize = engineSize;
    }
    
    protected override void OnEngineStarted()
    {
        Console.WriteLine($"{Make} {Model}: {EngineSize}cc motorcycle engine started");
    }
    
    protected override void OnEngineStopped()
    {
        Console.WriteLine($"{Make} {Model}: Motorcycle engine stopped");
    }
    
    public override FuelConsumption CalculateFuelConsumption(Distance distance)
    {
        var efficiency = CalculateMotorcycleEfficiency();
        return new FuelConsumption(distance.Kilometers / efficiency, FuelType.Gasoline);
    }
    
    private double CalculateMotorcycleEfficiency()
    {
        // エンジンサイズに基づく効率計算
        return EngineSize switch
        {
            <= 250 => 35.0,  // km/L
            <= 500 => 25.0,
            <= 1000 => 20.0,
            _ => 15.0
        };
    }
    
    // Motorcycle固有の振る舞い
    public void PopWheeling()
    {
        if (Status == VehicleStatus.Running)
            Console.WriteLine("Wheelie performed!");
    }
}
```

### 5.3.2 委譲(Delegation)の活用

#### 「has-a」関係の実装

```csharp
// 委譲を使った柔軟な設計
public interface IPaymentProcessor
{
    Task<PaymentResult> ProcessAsync(PaymentRequest request);
}

public interface IInventoryService
{
    Task<InventoryResult> ReserveAsync(ProductId productId, int quantity);
    Task ReleaseAsync(ProductId productId, int quantity);
}

public interface INotificationService
{
    Task SendOrderConfirmationAsync(Order order);
}

// 継承ではなく委譲を使用
public class OrderService
{
    private readonly IPaymentProcessor _paymentProcessor;
    private readonly IInventoryService _inventoryService;
    private readonly INotificationService _notificationService;
    private readonly IOrderRepository _orderRepository;
    private readonly ILogger<OrderService> _logger;
    
    public OrderService(
        IPaymentProcessor paymentProcessor,
        IInventoryService inventoryService,
        INotificationService notificationService,
        IOrderRepository orderRepository,
        ILogger<OrderService> logger)
    {
        _paymentProcessor = paymentProcessor;
        _inventoryService = inventoryService;
        _notificationService = notificationService;
        _orderRepository = orderRepository;
        _logger = logger;
    }
    
    public async Task<OrderProcessingResult> ProcessOrderAsync(CreateOrderCommand command)
    {
        try
        {
            // 1. 注文作成
            var order = Order.Create(command.CustomerId, command.Items);
            
            // 2. 在庫引当(委譲)
            var inventoryResult = await ReserveInventoryAsync(order);
            if (!inventoryResult.IsSuccess)
                return OrderProcessingResult.Failed(inventoryResult.ErrorMessage);
            
            // 3. 決済処理(委譲)
            var paymentResult = await ProcessPaymentAsync(order);
            if (!paymentResult.IsSuccess)
            {
                await ReleaseInventoryAsync(order);
                return OrderProcessingResult.Failed(paymentResult.ErrorMessage);
            }
            
            // 4. 注文確定
            order.Confirm();
            await _orderRepository.SaveAsync(order);
            
            // 5. 通知送信(委譲)
            await _notificationService.SendOrderConfirmationAsync(order);
            
            _logger.LogInformation("Order {OrderId} processed successfully", order.Id);
            return OrderProcessingResult.Success(order);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process order for customer {CustomerId}", command.CustomerId);
            return OrderProcessingResult.Failed("An unexpected error occurred");
        }
    }
    
    private async Task<InventoryResult> ReserveInventoryAsync(Order order)
    {
        foreach (var item in order.Items)
        {
            var result = await _inventoryService.ReserveAsync(item.ProductId, item.Quantity);
            if (!result.IsSuccess)
            {
                // 既に引当済みのアイテムを戻す
                await ReleaseInventoryAsync(order);
                return result;
            }
        }
        return InventoryResult.Success();
    }
    
    private async Task ReleaseInventoryAsync(Order order)
    {
        foreach (var item in order.Items)
        {
            try
            {
                await _inventoryService.ReleaseAsync(item.ProductId, item.Quantity);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to release inventory for product {ProductId}", item.ProductId);
            }
        }
    }
    
    private async Task<PaymentResult> ProcessPaymentAsync(Order order)
    {
        var paymentRequest = new PaymentRequest
        {
            OrderId = order.Id,
            Amount = order.Total,
            CustomerId = order.CustomerId,
            PaymentMethod = order.PaymentMethod
        };
        
        return await _paymentProcessor.ProcessAsync(paymentRequest);
    }
}
```

### 5.3.3 Composition over Inheritance

#### Strategy パターンによる柔軟な設計

```csharp
// 継承ベースの設計(硬直的)
public abstract class ShippingCalculator
{
    public abstract decimal CalculateShippingCost(Package package, Address destination);
}

public class StandardShippingCalculator : ShippingCalculator
{
    public override decimal CalculateShippingCost(Package package, Address destination)
    {
        return package.Weight * 5.0m;
    }
}

public class ExpressShippingCalculator : ShippingCalculator
{
    public override decimal CalculateShippingCost(Package package, Address destination)
    {
        return package.Weight * 15.0m + 25.0m;
    }
}

// 委譲ベースの設計(柔軟)
public interface IShippingStrategy
{
    decimal CalculateCost(Package package, Address destination);
    TimeSpan EstimateDeliveryTime(Address destination);
    bool IsAvailableFor(Address destination);
}

public class ShippingService
{
    private readonly Dictionary<ShippingType, IShippingStrategy> _strategies;
    
    public ShippingService(IEnumerable<IShippingStrategy> strategies)
    {
        _strategies = strategies.ToDictionary(s => s.GetType().Name switch
        {
            nameof(StandardShippingStrategy) => ShippingType.Standard,
            nameof(ExpressShippingStrategy) => ShippingType.Express,
            nameof(OvernightShippingStrategy) => ShippingType.Overnight,
            _ => throw new ArgumentException($"Unknown strategy: {s.GetType().Name}")
        });
    }
    
    public IEnumerable<ShippingOption> GetAvailableOptions(Package package, Address destination)
    {
        return _strategies
            .Where(kvp => kvp.Value.IsAvailableFor(destination))
            .Select(kvp => new ShippingOption
            {
                Type = kvp.Key,
                Cost = kvp.Value.CalculateCost(package, destination),
                EstimatedDelivery = DateTime.Now.Add(kvp.Value.EstimateDeliveryTime(destination))
            });
    }
    
    public ShippingQuote CalculateShipping(Package package, Address destination, ShippingType type)
    {
        if (!_strategies.TryGetValue(type, out var strategy))
            throw new ArgumentException($"Unsupported shipping type: {type}");
            
        if (!strategy.IsAvailableFor(destination))
            throw new InvalidOperationException($"{type} shipping is not available for the destination");
            
        return new ShippingQuote
        {
            Type = type,
            Cost = strategy.CalculateCost(package, destination),
            EstimatedDelivery = DateTime.Now.Add(strategy.EstimateDeliveryTime(destination))
        };
    }
}

// 具体的な戦略実装
public class StandardShippingStrategy : IShippingStrategy
{
    public decimal CalculateCost(Package package, Address destination)
    {
        var baseCost = package.Weight * 5.0m;
        var distanceMultiplier = destination.IsRemote ? 1.5m : 1.0m;
        return baseCost * distanceMultiplier;
    }
    
    public TimeSpan EstimateDeliveryTime(Address destination)
    {
        return destination.IsRemote ? TimeSpan.FromDays(7) : TimeSpan.FromDays(5);
    }
    
    public bool IsAvailableFor(Address destination)
    {
        return true; // 標準配送はどこでも利用可能
    }
}

public class ExpressShippingStrategy : IShippingStrategy
{
    public decimal CalculateCost(Package package, Address destination)
    {
        var baseCost = package.Weight * 15.0m;
        var expressFee = 25.0m;
        var urgentFee = destination.IsRemote ? 10.0m : 0m;
        return baseCost + expressFee + urgentFee;
    }
    
    public TimeSpan EstimateDeliveryTime(Address destination)
    {
        return destination.IsRemote ? TimeSpan.FromDays(2) : TimeSpan.FromDays(1);
    }
    
    public bool IsAvailableFor(Address destination)
    {
        return !destination.IsInternational; // 国内のみ
    }
}
```

## 5.4 ポリモーフィズムの効果的活用

### 5.4.1 ポリモーフィズムの種類

#### サブタイプポリモーフィズム

```csharp
// 基底インターフェース
public interface IReportGenerator
{
    Task<Report> GenerateAsync(ReportRequest request);
    string GetSupportedFormat();
}

// 異なる実装
public class PdfReportGenerator : IReportGenerator
{
    private readonly IPdfEngine _pdfEngine;
    
    public PdfReportGenerator(IPdfEngine pdfEngine)
    {
        _pdfEngine = pdfEngine;
    }
    
    public async Task<Report> GenerateAsync(ReportRequest request)
    {
        var document = await CreatePdfDocumentAsync(request);
        var bytes = await _pdfEngine.RenderToBytesAsync(document);
        
        return new Report
        {
            Content = bytes,
            ContentType = "application/pdf",
            FileName = $"{request.Title}.pdf"
        };
    }
    
    public string GetSupportedFormat() => "PDF";
    
    private async Task<PdfDocument> CreatePdfDocumentAsync(ReportRequest request)
    {
        // PDF固有の処理
        return new PdfDocument(request.Title, request.Data);
    }
}

public class ExcelReportGenerator : IReportGenerator
{
    private readonly IExcelEngine _excelEngine;
    
    public ExcelReportGenerator(IExcelEngine excelEngine)
    {
        _excelEngine = excelEngine;
    }
    
    public async Task<Report> GenerateAsync(ReportRequest request)
    {
        var workbook = await CreateExcelWorkbookAsync(request);
        var bytes = await _excelEngine.SaveToStreamAsync(workbook);
        
        return new Report
        {
            Content = bytes,
            ContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            FileName = $"{request.Title}.xlsx"
        };
    }
    
    public string GetSupportedFormat() => "Excel";
    
    private async Task<ExcelWorkbook> CreateExcelWorkbookAsync(ReportRequest request)
    {
        // Excel固有の処理
        return new ExcelWorkbook(request.Title, request.Data);
    }
}

// ポリモーフィズムを活用するクライアント
public class ReportService
{
    private readonly Dictionary<string, IReportGenerator> _generators;
    
    public ReportService(IEnumerable<IReportGenerator> generators)
    {
        _generators = generators.ToDictionary(g => g.GetSupportedFormat().ToUpper());
    }
    
    public async Task<Report> GenerateReportAsync(ReportRequest request, string format)
    {
        if (!_generators.TryGetValue(format.ToUpper(), out var generator))
        {
            var supportedFormats = string.Join(", ", _generators.Keys);
            throw new ArgumentException($"Unsupported format: {format}. Supported formats: {supportedFormats}");
        }
        
        // 具体的な実装に関係なく同じインターフェースで処理
        return await generator.GenerateAsync(request);
    }
    
    public IEnumerable<string> GetSupportedFormats()
    {
        return _generators.Keys;
    }
}
```

#### パラメトリックポリモーフィズム(ジェネリクス)

```csharp
// ジェネリック型による抽象化
public interface IRepository<TEntity, TKey> where TEntity : class
{
    Task<TEntity> FindByIdAsync(TKey id);
    Task<IEnumerable<TEntity>> FindAllAsync();
    Task<TEntity> SaveAsync(TEntity entity);
    Task DeleteAsync(TKey id);
}

public abstract class RepositoryBase<TEntity, TKey> : IRepository<TEntity, TKey> 
    where TEntity : class
{
    protected readonly DbContext _context;
    protected readonly DbSet<TEntity> _dbSet;
    
    protected RepositoryBase(DbContext context)
    {
        _context = context;
        _dbSet = context.Set<TEntity>();
    }
    
    public virtual async Task<TEntity> FindByIdAsync(TKey id)
    {
        return await _dbSet.FindAsync(id);
    }
    
    public virtual async Task<IEnumerable<TEntity>> FindAllAsync()
    {
        return await _dbSet.ToListAsync();
    }
    
    public virtual async Task<TEntity> SaveAsync(TEntity entity)
    {
        var entry = _context.Entry(entity);
        if (entry.State == EntityState.Detached)
        {
            _dbSet.Add(entity);
        }
        else
        {
            _dbSet.Update(entity);
        }
        
        await _context.SaveChangesAsync();
        return entity;
    }
    
    public virtual async Task DeleteAsync(TKey id)
    {
        var entity = await FindByIdAsync(id);
        if (entity != null)
        {
            _dbSet.Remove(entity);
            await _context.SaveChangesAsync();
        }
    }
}

// 具体的な実装
public class CustomerRepository : RepositoryBase<Customer, int>
{
    public CustomerRepository(DbContext context) : base(context) { }
    
    // Customer固有のメソッド
    public async Task<Customer> FindByEmailAsync(string email)
    {
        return await _dbSet.FirstOrDefaultAsync(c => c.Email == email);
    }
    
    public async Task<IEnumerable<Customer>> FindByStatusAsync(CustomerStatus status)
    {
        return await _dbSet.Where(c => c.Status == status).ToListAsync();
    }
}

public class ProductRepository : RepositoryBase<Product, Guid>
{
    public ProductRepository(DbContext context) : base(context) { }
    
    // Product固有のメソッド
    public async Task<IEnumerable<Product>> FindByCategoryAsync(int categoryId)
    {
        return await _dbSet.Where(p => p.CategoryId == categoryId).ToListAsync();
    }
    
    public async Task<IEnumerable<Product>> FindByPriceRangeAsync(decimal minPrice, decimal maxPrice)
    {
        return await _dbSet.Where(p => p.Price >= minPrice && p.Price <= maxPrice).ToListAsync();
    }
}
```

### 5.4.2 Visitor パターンによる操作の拡張

```csharp
// Visitor パターン:型に新しい操作を追加
public interface IShapeVisitor<T>
{
    T VisitCircle(Circle circle);
    T VisitRectangle(Rectangle rectangle);
    T VisitTriangle(Triangle triangle);
}

public abstract class Shape
{
    public abstract T Accept<T>(IShapeVisitor<T> visitor);
}

public class Circle : Shape
{
    public double Radius { get; }
    public Point Center { get; }
    
    public Circle(double radius, Point center)
    {
        Radius = radius;
        Center = center;
    }
    
    public override T Accept<T>(IShapeVisitor<T> visitor)
    {
        return visitor.VisitCircle(this);
    }
}

public class Rectangle : Shape
{
    public double Width { get; }
    public double Height { get; }
    public Point TopLeft { get; }
    
    public Rectangle(double width, double height, Point topLeft)
    {
        Width = width;
        Height = height;
        TopLeft = topLeft;
    }
    
    public override T Accept<T>(IShapeVisitor<T> visitor)
    {
        return visitor.VisitRectangle(this);
    }
}

public class Triangle : Shape
{
    public Point[] Vertices { get; }
    
    public Triangle(Point[] vertices)
    {
        if (vertices.Length != 3)
            throw new ArgumentException("Triangle must have exactly 3 vertices");
        Vertices = vertices;
    }
    
    public override T Accept<T>(IShapeVisitor<T> visitor)
    {
        return visitor.VisitTriangle(this);
    }
}

// 面積計算のVisitor
public class AreaCalculatorVisitor : IShapeVisitor<double>
{
    public double VisitCircle(Circle circle)
    {
        return Math.PI * circle.Radius * circle.Radius;
    }
    
    public double VisitRectangle(Rectangle rectangle)
    {
        return rectangle.Width * rectangle.Height;
    }
    
    public double VisitTriangle(Triangle triangle)
    {
        // ヘロンの公式を使用
        var a = Distance(triangle.Vertices[0], triangle.Vertices[1]);
        var b = Distance(triangle.Vertices[1], triangle.Vertices[2]);
        var c = Distance(triangle.Vertices[2], triangle.Vertices[0]);
        
        var s = (a + b + c) / 2;
        return Math.Sqrt(s * (s - a) * (s - b) * (s - c));
    }
    
    private double Distance(Point p1, Point p2)
    {
        return Math.Sqrt(Math.Pow(p2.X - p1.X, 2) + Math.Pow(p2.Y - p1.Y, 2));
    }
}

// 描画のVisitor
public class DrawVisitor : IShapeVisitor<string>
{
    public string VisitCircle(Circle circle)
    {
        return $"Drawing circle with radius {circle.Radius} at ({circle.Center.X}, {circle.Center.Y})";
    }
    
    public string VisitRectangle(Rectangle rectangle)
    {
        return $"Drawing rectangle {rectangle.Width}x{rectangle.Height} at ({rectangle.TopLeft.X}, {rectangle.TopLeft.Y})";
    }
    
    public string VisitTriangle(Triangle triangle)
    {
        var points = string.Join(", ", triangle.Vertices.Select(v => $"({v.X}, {v.Y})"));
        return $"Drawing triangle with vertices: {points}";
    }
}

// 使用例
public class ShapeProcessor
{
    public void ProcessShapes(IEnumerable<Shape> shapes)
    {
        var areaCalculator = new AreaCalculatorVisitor();
        var drawer = new DrawVisitor();
        
        foreach (var shape in shapes)
        {
            var area = shape.Accept(areaCalculator);
            var drawCommand = shape.Accept(drawer);
            
            Console.WriteLine($"{drawCommand} (Area: {area:F2})");
        }
    }
}
```

## 5.5 実践演習:オブジェクト指向設計

### 5.5.1 要求分析から設計へ

#### 演習:ECサイトの注文処理システム

**要求**:
1. 顧客は商品をカートに追加できる
2. 複数の支払い方法に対応(クレジットカード、PayPal、銀行振込)
3. 配送方法を選択できる(標準、速達、翌日配送)
4. 割引システム(会員割引、数量割引、キャンペーン割引)
5. 在庫管理と引当
6. 注文状況の追跡

#### Step 1: ドメインモデルの抽出

```csharp
// 核心となるドメインオブジェクト
public class Customer
{
    public CustomerId Id { get; }
    public string Name { get; }
    public EmailAddress Email { get; }
    public CustomerType Type { get; private set; }
    public Address DefaultAddress { get; private set; }
    
    public Customer(CustomerId id, string name, EmailAddress email, CustomerType type)
    {
        Id = id;
        Name = name;
        Email = email;
        Type = type;
    }
    
    public void UpgradeToMember(CustomerType newType)
    {
        if (newType <= Type)
            throw new InvalidOperationException("Cannot downgrade customer type");
            
        Type = newType;
        DomainEvents.Raise(new CustomerUpgradedEvent(Id, newType));
    }
}

public class ShoppingCart
{
    private readonly Dictionary<ProductId, CartItem> _items = new();
    
    public CustomerId CustomerId { get; }
    public IReadOnlyCollection<CartItem> Items => _items.Values;
    public Money Total => Items.Select(item => item.LineTotal).Aggregate(Money.Zero, (sum, total) => sum.Add(total));
    
    public ShoppingCart(CustomerId customerId)
    {
        CustomerId = customerId;
    }
    
    public void AddItem(Product product, int quantity)
    {
        if (_items.TryGetValue(product.Id, out var existingItem))
        {
            existingItem.UpdateQuantity(existingItem.Quantity + quantity);
        }
        else
        {
            _items[product.Id] = new CartItem(product, quantity);
        }
    }
    
    public Order CreateOrder(Address shippingAddress, PaymentMethod paymentMethod, ShippingMethod shippingMethod)
    {
        if (!Items.Any())
            throw new InvalidOperationException("Cannot create order from empty cart");
            
        return Order.Create(CustomerId, Items.ToList(), shippingAddress, paymentMethod, shippingMethod);
    }
}
```

#### Step 2: 責務の分離

```csharp
// 支払い処理の抽象化
public interface IPaymentProcessor
{
    Task<PaymentResult> ProcessAsync(PaymentRequest request);
    PaymentMethod SupportedMethod { get; }
}

public class CreditCardPaymentProcessor : IPaymentProcessor
{
    private readonly ICreditCardGateway _gateway;
    
    public PaymentMethod SupportedMethod => PaymentMethod.CreditCard;
    
    public CreditCardPaymentProcessor(ICreditCardGateway gateway)
    {
        _gateway = gateway;
    }
    
    public async Task<PaymentResult> ProcessAsync(PaymentRequest request)
    {
        var cardInfo = (CreditCardInfo)request.PaymentDetails;
        
        var gatewayRequest = new CreditCardChargeRequest
        {
            Amount = request.Amount,
            CardNumber = cardInfo.Number,
            ExpiryDate = cardInfo.ExpiryDate,
            CVV = cardInfo.CVV,
            HolderName = cardInfo.HolderName
        };
        
        var gatewayResponse = await _gateway.ChargeAsync(gatewayRequest);
        
        return gatewayResponse.IsSuccess
            ? PaymentResult.Success(gatewayResponse.TransactionId)
            : PaymentResult.Failure(gatewayResponse.ErrorMessage);
    }
}

// 割引計算の抽象化
public interface IDiscountCalculator
{
    Money CalculateDiscount(Order order, Customer customer);
    bool IsApplicable(Order order, Customer customer);
}

public class MemberDiscountCalculator : IDiscountCalculator
{
    public Money CalculateDiscount(Order order, Customer customer)
    {
        var discountRate = customer.Type switch
        {
            CustomerType.Silver => 0.05m,
            CustomerType.Gold => 0.10m,
            CustomerType.Platinum => 0.15m,
            _ => 0m
        };
        
        return order.Subtotal.Multiply(discountRate);
    }
    
    public bool IsApplicable(Order order, Customer customer)
    {
        return customer.Type != CustomerType.Regular;
    }
}

public class VolumeDiscountCalculator : IDiscountCalculator
{
    public Money CalculateDiscount(Order order, Customer customer)
    {
        var totalQuantity = order.Items.Sum(item => item.Quantity);
        
        var discountRate = totalQuantity switch
        {
            >= 20 => 0.15m,
            >= 10 => 0.10m,
            >= 5 => 0.05m,
            _ => 0m
        };
        
        return order.Subtotal.Multiply(discountRate);
    }
    
    public bool IsApplicable(Order order, Customer customer)
    {
        return order.Items.Sum(item => item.Quantity) >= 5;
    }
}
```

#### Step 3: ポリモーフィズムの活用

```csharp
// 注文処理サービス
public class OrderProcessingService
{
    private readonly IEnumerable<IPaymentProcessor> _paymentProcessors;
    private readonly IEnumerable<IDiscountCalculator> _discountCalculators;
    private readonly IInventoryService _inventoryService;
    private readonly IShippingService _shippingService;
    private readonly IOrderRepository _orderRepository;
    
    public OrderProcessingService(
        IEnumerable<IPaymentProcessor> paymentProcessors,
        IEnumerable<IDiscountCalculator> discountCalculators,
        IInventoryService inventoryService,
        IShippingService shippingService,
        IOrderRepository orderRepository)
    {
        _paymentProcessors = paymentProcessors;
        _discountCalculators = discountCalculators;
        _inventoryService = inventoryService;
        _shippingService = shippingService;
        _orderRepository = orderRepository;
    }
    
    public async Task<OrderResult> ProcessOrderAsync(ProcessOrderCommand command)
    {
        try
        {
            // 1. 注文作成
            var order = CreateOrderFromCommand(command);
            
            // 2. 割引計算(複数の計算機を適用)
            var totalDiscount = CalculateDiscounts(order, command.Customer);
            order.ApplyDiscount(totalDiscount);
            
            // 3. 配送料計算
            var shippingCost = await _shippingService.CalculateShippingCostAsync(order);
            order.AddShippingCost(shippingCost);
            
            // 4. 在庫引当
            var inventoryResult = await _inventoryService.ReserveItemsAsync(order);
            if (!inventoryResult.IsSuccess)
                return OrderResult.InventoryFailure(inventoryResult.ErrorMessage);
            
            // 5. 決済処理(適切なプロセッサーを選択)
            var paymentProcessor = _paymentProcessors.First(p => p.SupportedMethod == order.PaymentMethod.Type);
            var paymentResult = await paymentProcessor.ProcessAsync(CreatePaymentRequest(order));
            
            if (!paymentResult.IsSuccess)
            {
                await _inventoryService.ReleaseItemsAsync(order);
                return OrderResult.PaymentFailure(paymentResult.ErrorMessage);
            }
            
            // 6. 注文確定
            order.ConfirmPayment(paymentResult.TransactionId);
            await _orderRepository.SaveAsync(order);
            
            return OrderResult.Success(order);
        }
        catch (Exception ex)
        {
            return OrderResult.SystemFailure(ex.Message);
        }
    }
    
    private Money CalculateDiscounts(Order order, Customer customer)
    {
        return _discountCalculators
            .Where(calc => calc.IsApplicable(order, customer))
            .Select(calc => calc.CalculateDiscount(order, customer))
            .Aggregate(Money.Zero, (sum, discount) => sum.Add(discount));
    }
}
```

#### Step 4: 拡張性の確保

```csharp
// 新しい支払い方法の追加(既存コードの変更不要)
public class PayPalPaymentProcessor : IPaymentProcessor
{
    private readonly IPayPalService _paypalService;
    
    public PaymentMethod SupportedMethod => PaymentMethod.PayPal;
    
    public PayPalPaymentProcessor(IPayPalService paypalService)
    {
        _paypalService = paypalService;
    }
    
    public async Task<PaymentResult> ProcessAsync(PaymentRequest request)
    {
        var paypalInfo = (PayPalInfo)request.PaymentDetails;
        
        var paypalRequest = new PayPalChargeRequest
        {
            Amount = request.Amount.Amount,
            Currency = request.Amount.Currency.ToString(),
            PayPalEmail = paypalInfo.Email,
            PayPalToken = paypalInfo.Token
        };
        
        var response = await _paypalService.ProcessPaymentAsync(paypalRequest);
        
        return response.Success
            ? PaymentResult.Success(response.TransactionId)
            : PaymentResult.Failure(response.ErrorCode);
    }
}

// 新しい割引ルールの追加(既存コードの変更不要)
public class CampaignDiscountCalculator : IDiscountCalculator
{
    private readonly ICampaignService _campaignService;
    
    public CampaignDiscountCalculator(ICampaignService campaignService)
    {
        _campaignService = campaignService;
    }
    
    public Money CalculateDiscount(Order order, Customer customer)
    {
        var activeCampaigns = _campaignService.GetActiveCampaigns(DateTime.Now);
        
        var bestDiscount = Money.Zero;
        foreach (var campaign in activeCampaigns)
        {
            if (campaign.IsEligible(order, customer))
            {
                var discount = campaign.CalculateDiscount(order);
                if (discount.Amount > bestDiscount.Amount)
                    bestDiscount = discount;
            }
        }
        
        return bestDiscount;
    }
    
    public bool IsApplicable(Order order, Customer customer)
    {
        var activeCampaigns = _campaignService.GetActiveCampaigns(DateTime.Now);
        return activeCampaigns.Any(campaign => campaign.IsEligible(order, customer));
    }
}
```

## まとめ

第5章では、オブジェクト指向設計の真髄について学んだ。単一責務原則、カプセル化、継承と委譲の適切な使い分け、そしてポリモーフィズムの効果的な活用方法を理解した。

### 重要なポイント

1. **単一責務原則**:変更の理由に着目し、アクターごとに責務を分離する
2. **カプセル化**:データと振る舞いを適切に組み合わせ、内部実装を隠蔽する
3. **継承vs委譲**:「is-a」関係には継承、「has-a」関係には委譲を使用
4. **ポリモーフィズム**:異なる実装を統一的なインターフェースで扱い、拡張性を確保

これらの原則を適切に適用することで、保守性が高く、拡張しやすいソフトウェアを構築できる。

次章では、これらの設計原則を活かしながら「テスト駆動開発とTestable設計」について学ぶ。美しいコードの七箇条の最後の項目である「Testable」を実現するための具体的な技法と、テストファーストによる開発手法を身につけていく。