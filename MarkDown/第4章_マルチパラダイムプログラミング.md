# 第4章 マルチパラダイムプログラミング

## 4.1 パラダイムの進化と選択

### 4.1.1 プログラミングパラダイムとは

プログラミングパラダイムとは、プログラムを構築するための基本的な考え方や手法の体系である。現代のソフトウェア開発において**マルチパラダイムプログラミング**は重要である。

> 「マルチパラダイムプログラミングが現実的なものとなりつつある」

これは、単一のパラダイムに固執するのではなく、問題の性質に応じて最適なパラダイムを選択し、それらを組み合わせて使用することの重要性を示している。

![プログラミングパラダイム比較表](Images/programming-paradigms-comparison.md)

### 4.1.2 主要なプログラミングパラダイム

#### 命令型プログラミング(Imperative Programming)
- **特徴**:「どうやって(How)」処理を行うかを詳細に記述
- **焦点**:処理の手順と状態の変化
- **代表的言語**:C、Pascal、アセンブリ言語

```csharp
// 命令型スタイル:手順を詳細に記述
public decimal CalculateTotal(List<OrderItem> items)
{
    decimal total = 0;
    for (int i = 0; i < items.Count; i++)
    {
        total += items[i].Price * items[i].Quantity;
    }
    return total;
}
```

#### 宣言型プログラミング(Declarative Programming)
- **特徴**:「何を(What)」実現したいかを記述
- **焦点**:期待する結果や制約条件
- **代表例**:SQL、HTML、関数型言語

```csharp
// 宣言型スタイル:結果を記述
public decimal CalculateTotal(List<OrderItem> items)
{
    return items.Sum(item => item.Price * item.Quantity);
}
```

#### オブジェクト指向プログラミング(Object-Oriented Programming)
- **特徴**:オブジェクトの相互作用でシステムを構築
- **焦点**:データと振る舞いの組み合わせ
- **核心概念**:カプセル化、継承、ポリモーフィズム

```csharp
// オブジェクト指向スタイル:責務の分散
public class OrderCalculator
{
    public Money CalculateTotal(Order order)
    {
        return order.Items
            .Select(item => item.CalculateLineTotal())
            .Aggregate(Money.Zero, (sum, lineTotal) => sum.Add(lineTotal));
    }
}

public class OrderItem
{
    public Money CalculateLineTotal()
    {
        return Price.Multiply(Quantity);
    }
}
```

#### 関数型プログラミング(Functional Programming)
- **特徴**:関数の組み合わせでシステムを構築
- **焦点**:不変性、副作用の排除、高階関数
- **核心概念**:純粋関数、不変性、合成

```csharp
// 関数型スタイル:関数の合成
public static class OrderCalculations
{
    public static decimal CalculateTotal(IEnumerable<OrderItem> items) =>
        items.Map(CalculateLineTotal)
             .Reduce(0m, (sum, lineTotal) => sum + lineTotal);
    
    private static decimal CalculateLineTotal(OrderItem item) =>
        item.Price * item.Quantity;
}
```

### 4.1.3 C#におけるマルチパラダイムの進化

C#は当初はオブジェクト指向言語として設計されたが、バージョンアップを重ねてマルチパラダイム言語へと進化している。

#### C# 1.0-2.0: オブジェクト指向中心
```csharp
// C# 1.0時代:純粋なオブジェクト指向
public class StringProcessor
{
    public string[] FilterAndSort(string[] inputs)
    {
        ArrayList filtered = new ArrayList();
        for (int i = 0; i < inputs.Length; i++)
        {
            if (inputs[i].Length > 3)
            {
                filtered.Add(inputs[i]);
            }
        }
        
        string[] result = new string[filtered.Count];
        filtered.CopyTo(result);
        Array.Sort(result);
        return result;
    }
}
```

#### C# 3.0: 関数型要素の導入
```csharp
// C# 3.0:LINQ、ラムダ式、拡張メソッド
public static class StringProcessor
{
    public static IEnumerable<string> FilterAndSort(this IEnumerable<string> inputs)
    {
        return inputs.Where(s => s.Length > 3)
                    .OrderBy(s => s);
    }
}
```

#### C# 7.0-12.0: さらなるマルチパラダイム化
```csharp
// C# 現代版:パターンマッチング、レコード、関数型構文
public record OrderSummary(decimal Subtotal, decimal Tax, decimal Total);

public static class OrderAnalyzer
{
    public static OrderSummary AnalyzeOrder(Order order) => order switch
    {
        { Items.Count: 0 } => new(0, 0, 0),
        { Customer.Type: CustomerType.Premium } => CalculateWithDiscount(order, 0.1m),
        { Total: > 1000 } => CalculateWithDiscount(order, 0.05m),
        _ => CalculateStandard(order)
    };
    
    private static OrderSummary CalculateWithDiscount(Order order, decimal discountRate) =>
        order.Items
             .Select(item => item.Price * item.Quantity)
             .Aggregate((sum, price) => sum + price)
             .Apply(subtotal => new OrderSummary(
                 Subtotal: subtotal * (1 - discountRate),
                 Tax: subtotal * 0.1m,
                 Total: subtotal * (1 + 0.1m - discountRate)));
}

// 関数型の拡張メソッド
public static class FunctionalExtensions
{
    public static TResult Apply<T, TResult>(this T value, Func<T, TResult> func) =>
        func(value);
}
```

## 4.2 命令型vs宣言型プログラミング

### 4.2.1 意図の表現における違い

命令型と宣言型の最も重要な違いは、**意図の表現方法**にある。

#### 命令型:How(どうやって)を記述

```csharp
// 命令型:処理手順を詳細に記述
public List<Customer> FindActiveCustomersInRegion(List<Customer> customers, string region)
{
    List<Customer> result = new List<Customer>();
    
    for (int i = 0; i < customers.Count; i++)
    {
        Customer customer = customers[i];
        if (customer.IsActive && customer.Region == region)
        {
            result.Add(customer);
        }
    }
    
    // ソート処理
    for (int i = 0; i < result.Count - 1; i++)
    {
        for (int j = i + 1; j < result.Count; j++)
        {
            if (string.Compare(result[i].Name, result[j].Name) > 0)
            {
                Customer temp = result[i];
                result[i] = result[j];
                result[j] = temp;
            }
        }
    }
    
    return result;
}
```

この実装の問題点:
- **ノイズが多い**:ループ変数、インデックス、一時変数
- **意図が埋もれる**:「何をしたいか」が実装詳細に埋もれている
- **エラーが起きやすい**:配列の境界やインデックスの管理

#### 宣言型:What(何を)を記述

```csharp
// 宣言型:結果を記述
public IEnumerable<Customer> FindActiveCustomersInRegion(
    IEnumerable<Customer> customers, 
    string region)
{
    return customers
        .Where(customer => customer.IsActive && customer.Region == region)
        .OrderBy(customer => customer.Name);
}
```

改善された点:
- **意図が明確**:「アクティブな顧客を地域で絞り込み、名前でソート」
- **ノイズが少ない**:実装詳細が隠蔽されている
- **安全性が高い**:境界チェックやメモリ管理は言語が担当

### 4.2.2 問題領域に応じた選択

#### 命令型が適している場面

**低レベル制御が必要な場合**:
```csharp
// ハードウェア制御:命令型が適している
public class HardwareController
{
    public void InitializeDevice()
    {
        // 正確な順序での処理が必要
        WriteRegister(0x00, 0xFF);
        Thread.Sleep(10); // 正確なタイミング制御
        WriteRegister(0x01, 0x00);
        
        // デバイスの応答を確認
        byte status = ReadRegister(0x02);
        if ((status & 0x80) == 0)
        {
            throw new DeviceInitializationException("Device failed to initialize");
        }
    }
}
```

**複雑なアルゴリズムの実装**:
```csharp
// 最適化されたソートアルゴリズム
public static void QuickSort<T>(T[] array, int left, int right, IComparer<T> comparer)
{
    if (left < right)
    {
        int pivot = Partition(array, left, right, comparer);
        QuickSort(array, left, pivot - 1, comparer);
        QuickSort(array, pivot + 1, right, comparer);
    }
}
```

#### 宣言型が適している場面

**データ変換・フィルタリング**:
```csharp
// データ分析:宣言型が適している
public class SalesAnalyzer
{
    public SalesReport GenerateQuarterlySummary(IEnumerable<Sale> sales)
    {
        var quarterlySales = sales
            .Where(sale => sale.Date >= QuarterStart && sale.Date <= QuarterEnd)
            .GroupBy(sale => sale.ProductCategory)
            .Select(group => new CategorySummary
            {
                Category = group.Key,
                TotalSales = group.Sum(sale => sale.Amount),
                TransactionCount = group.Count(),
                AverageOrderValue = group.Average(sale => sale.Amount)
            })
            .OrderByDescending(summary => summary.TotalSales);
            
        return new SalesReport
        {
            Period = $"Q{GetQuarter()} {DateTime.Now.Year}",
            Categories = quarterlySales.ToList(),
            GrandTotal = quarterlySales.Sum(c => c.TotalSales)
        };
    }
}
```

**設定・ルール定義**:
```csharp
// ビジネスルール:宣言型が適している
public class PricingRules
{
    public static readonly Dictionary<CustomerType, Func<Order, decimal>> DiscountRules = 
        new()
        {
            [CustomerType.Premium] = order => order.Total * 0.15m,
            [CustomerType.Regular] = order => order.Total > 1000 ? order.Total * 0.05m : 0,
            [CustomerType.New] = order => order.Items.Count > 5 ? order.Total * 0.1m : 0
        };
    
    public decimal CalculateDiscount(Order order)
    {
        return DiscountRules[order.Customer.Type](order);
    }
}
```

### 4.2.3 パラダイムの組み合わせ

現実のシステムでは、複数のパラダイムを組み合わせることで最適な解決策を実現する:

```csharp
public class OrderProcessingPipeline
{
    // 宣言型:処理パイプラインの定義
    private readonly IEnumerable<IOrderProcessor> _processors = new IOrderProcessor[]
    {
        new ValidationProcessor(),
        new PricingProcessor(),
        new InventoryProcessor(),
        new PaymentProcessor(),
        new NotificationProcessor()
    };
    
    // 関数型:エラーハンドリングとパイプライン実行
    public async Task<Result<Order>> ProcessOrderAsync(OrderRequest request)
    {
        return await ProcessOrderInternal(request)
            .ConfigureAwait(false);
    }
    
    private async Task<Result<Order>> ProcessOrderInternal(OrderRequest request)
    {
        var order = Order.FromRequest(request);
        
        // 関数型スタイル:チェーン処理
        return await _processors
            .Aggregate(
                Task.FromResult(Result.Success(order)),
                async (prevTask, processor) =>
                {
                    var prevResult = await prevTask;
                    if (prevResult.IsFailure)
                        return prevResult;
                        
                    return await processor.ProcessAsync(prevResult.Value);
                });
    }
}

// 各プロセッサは命令型で具体的な処理を実装
public class PaymentProcessor : IOrderProcessor
{
    public async Task<Result<Order>> ProcessAsync(Order order)
    {
        try
        {
            // 命令型:具体的な決済処理手順
            var paymentRequest = CreatePaymentRequest(order);
            var response = await _paymentGateway.ProcessAsync(paymentRequest);
            
            if (response.IsSuccess)
            {
                order.MarkAsPaid(response.TransactionId);
                return Result.Success(order);
            }
            
            return Result.Failure($"Payment failed: {response.ErrorMessage}");
        }
        catch (Exception ex)
        {
            return Result.Failure($"Payment processing error: {ex.Message}");
        }
    }
}
```

## 4.3 オブジェクト指向パラダイム

### 4.3.1 オブジェクト指向の本質

オブジェクト指向プログラミングは、現実世界の概念をオブジェクトとしてモデル化し、それらの相互作用でシステムを構築するパラダイムである。

#### 基本原則

**カプセル化(Encapsulation)**:
データと操作を一つのオブジェクトにまとめ、内部実装を隠蔽する。

```csharp
public class BankAccount
{
    private decimal _balance;  // 内部状態を隠蔽
    private readonly List<Transaction> _transactions = new();
    
    // 外部インターフェースのみを公開
    public decimal Balance => _balance;
    public IReadOnlyList<Transaction> Transactions => _transactions.AsReadOnly();
    
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("Deposit amount must be positive");
            
        _balance += amount;
        _transactions.Add(new Transaction(TransactionType.Deposit, amount, DateTime.Now));
    }
    
    public bool TryWithdraw(decimal amount, out WithdrawalResult result)
    {
        if (amount <= 0)
        {
            result = WithdrawalResult.InvalidAmount();
            return false;
        }
        
        if (_balance < amount)
        {
            result = WithdrawalResult.InsufficientFunds();
            return false;
        }
        
        _balance -= amount;
        _transactions.Add(new Transaction(TransactionType.Withdrawal, amount, DateTime.Now));
        result = WithdrawalResult.Success();
        return true;
    }
}
```

**継承(Inheritance)**:
共通の特性や振る舞いを継承階層で表現する。

```csharp
// 基底クラス:共通の概念を抽象化
public abstract class Vehicle
{
    public string Make { get; protected set; }
    public string Model { get; protected set; }
    public int Year { get; protected set; }
    
    protected Vehicle(string make, string model, int year)
    {
        Make = make;
        Model = model;
        Year = year;
    }
    
    // 共通の振る舞い
    public virtual void Start()
    {
        Console.WriteLine($"{Make} {Model} is starting...");
    }
    
    // 抽象的な振る舞い:派生クラスで実装
    public abstract decimal CalculateFuelConsumption(decimal distance);
}

// 具体的な実装
public class Car : Vehicle
{
    public decimal FuelEfficiency { get; }  // km/L
    
    public Car(string make, string model, int year, decimal fuelEfficiency) 
        : base(make, model, year)
    {
        FuelEfficiency = fuelEfficiency;
    }
    
    public override decimal CalculateFuelConsumption(decimal distance)
    {
        return distance / FuelEfficiency;
    }
    
    public override void Start()
    {
        base.Start();
        Console.WriteLine("Engine started. Ready to drive.");
    }
}

public class ElectricCar : Vehicle
{
    public decimal BatteryCapacity { get; }  // kWh
    public decimal Efficiency { get; }       // km/kWh
    
    public ElectricCar(string make, string model, int year, decimal batteryCapacity, decimal efficiency) 
        : base(make, model, year)
    {
        BatteryCapacity = batteryCapacity;
        Efficiency = efficiency;
    }
    
    public override decimal CalculateFuelConsumption(decimal distance)
    {
        return distance / Efficiency;  // 電力消費量 (kWh)
    }
    
    public override void Start()
    {
        base.Start();
        Console.WriteLine("Electric motor activated. Silent and ready.");
    }
}
```

**ポリモーフィズム(Polymorphism)**:
同じインターフェースで異なる実装を扱う。

```csharp
public class FleetManager
{
    private readonly List<Vehicle> _vehicles = new();
    
    public void AddVehicle(Vehicle vehicle)
    {
        _vehicles.Add(vehicle);
    }
    
    // ポリモーフィズム:型に関係なく同じ操作
    public FleetReport GenerateEfficiencyReport(decimal tripDistance)
    {
        var reports = _vehicles.Select(vehicle => new VehicleEfficiencyReport
        {
            Vehicle = $"{vehicle.Make} {vehicle.Model}",
            FuelConsumption = vehicle.CalculateFuelConsumption(tripDistance),
            Type = vehicle.GetType().Name
        }).ToList();
        
        return new FleetReport
        {
            TripDistance = tripDistance,
            VehicleReports = reports,
            AverageFuelConsumption = reports.Average(r => r.FuelConsumption)
        };
    }
    
    public void StartAllVehicles()
    {
        foreach (var vehicle in _vehicles)
        {
            vehicle.Start();  // 各車両の具体的な実装が呼ばれる
        }
    }
}
```

### 4.3.2 デザインパターンとオブジェクト指向

デザインパターンは、オブジェクト指向設計における共通的な問題に対する再利用可能な解決策である。

#### Strategy パターン

```csharp
// 戦略の抽象化
public interface IShippingStrategy
{
    decimal CalculateCost(Package package, Address destination);
    TimeSpan EstimateDeliveryTime(Address destination);
}

// 具体的な戦略
public class StandardShippingStrategy : IShippingStrategy
{
    public decimal CalculateCost(Package package, Address destination)
    {
        var baseCost = package.Weight * 5.0m;  // $5 per kg
        var distanceMultiplier = CalculateDistanceMultiplier(destination);
        return baseCost * distanceMultiplier;
    }
    
    public TimeSpan EstimateDeliveryTime(Address destination)
    {
        return TimeSpan.FromDays(5); // 標準配送は5日
    }
    
    private decimal CalculateDistanceMultiplier(Address destination)
    {
        // 距離に基づく計算
        return destination.IsRemote ? 1.5m : 1.0m;
    }
}

public class ExpressShippingStrategy : IShippingStrategy
{
    public decimal CalculateCost(Package package, Address destination)
    {
        var baseCost = package.Weight * 15.0m;  // $15 per kg (高額)
        return baseCost + 25.0m;  // 速達料金
    }
    
    public TimeSpan EstimateDeliveryTime(Address destination)
    {
        return TimeSpan.FromDays(1); // 速達は1日
    }
}

// コンテキスト
public class ShippingCalculator
{
    public ShippingQuote CalculateShipping(
        Package package, 
        Address destination, 
        IShippingStrategy strategy)
    {
        var cost = strategy.CalculateCost(package, destination);
        var deliveryTime = strategy.EstimateDeliveryTime(destination);
        
        return new ShippingQuote
        {
            Cost = cost,
            EstimatedDelivery = DateTime.Now.Add(deliveryTime),
            Strategy = strategy.GetType().Name
        };
    }
}
```

#### Observer パターン

```csharp
// イベントの定義
public class OrderStatusChangedEventArgs : EventArgs
{
    public Order Order { get; }
    public OrderStatus PreviousStatus { get; }
    public OrderStatus NewStatus { get; }
    
    public OrderStatusChangedEventArgs(Order order, OrderStatus previousStatus, OrderStatus newStatus)
    {
        Order = order;
        PreviousStatus = previousStatus;
        NewStatus = newStatus;
    }
}

// Subject(観察対象)
public class Order
{
    private OrderStatus _status;
    
    public event EventHandler<OrderStatusChangedEventArgs> StatusChanged;
    
    public OrderStatus Status
    {
        get => _status;
        private set
        {
            var previousStatus = _status;
            _status = value;
            OnStatusChanged(new OrderStatusChangedEventArgs(this, previousStatus, value));
        }
    }
    
    protected virtual void OnStatusChanged(OrderStatusChangedEventArgs e)
    {
        StatusChanged?.Invoke(this, e);
    }
    
    public void MarkAsShipped()
    {
        if (Status != OrderStatus.Paid)
            throw new InvalidOperationException("Order must be paid before shipping");
            
        Status = OrderStatus.Shipped;
    }
}

// Observer(観察者)
public class EmailNotificationService
{
    public void Subscribe(Order order)
    {
        order.StatusChanged += OnOrderStatusChanged;
    }
    
    private async void OnOrderStatusChanged(object sender, OrderStatusChangedEventArgs e)
    {
        switch (e.NewStatus)
        {
            case OrderStatus.Confirmed:
                await SendOrderConfirmationEmail(e.Order);
                break;
            case OrderStatus.Shipped:
                await SendShippingNotificationEmail(e.Order);
                break;
            case OrderStatus.Delivered:
                await SendDeliveryConfirmationEmail(e.Order);
                break;
        }
    }
}

public class InventoryUpdateService
{
    public void Subscribe(Order order)
    {
        order.StatusChanged += OnOrderStatusChanged;
    }
    
    private async void OnOrderStatusChanged(object sender, OrderStatusChangedEventArgs e)
    {
        if (e.NewStatus == OrderStatus.Confirmed)
        {
            await ReserveInventoryItems(e.Order);
        }
        else if (e.NewStatus == OrderStatus.Cancelled)
        {
            await ReleaseReservedItems(e.Order);
        }
    }
}
```

### 4.3.3 SOLID原則の実践

#### Single Responsibility Principle (SRP)

```csharp
// SRP違反:複数の責務が混在
public class BadUserService
{
    public void CreateUser(UserDto userDto)
    {
        // 責務1: バリデーション
        if (string.IsNullOrEmpty(userDto.Email))
            throw new ArgumentException("Email is required");
            
        // 責務2: データベース操作
        using var connection = new SqlConnection(connectionString);
        var command = new SqlCommand("INSERT INTO Users...", connection);
        command.ExecuteNonQuery();
        
        // 責務3: メール送信
        var smtpClient = new SmtpClient();
        smtpClient.Send("welcome@company.com", userDto.Email, "Welcome", "...");
        
        // 責務4: ログ出力
        File.AppendAllText("log.txt", $"User created: {userDto.Email}");
    }
}

// SRP準拠:責務を分離
public class UserService
{
    private readonly IUserValidator _validator;
    private readonly IUserRepository _repository;
    private readonly IEmailService _emailService;
    private readonly ILogger _logger;
    
    public async Task<CreateUserResult> CreateUserAsync(CreateUserCommand command)
    {
        var validationResult = _validator.Validate(command);
        if (!validationResult.IsValid)
            return CreateUserResult.ValidationFailed(validationResult.Errors);
            
        var user = User.Create(command.Name, command.Email);
        await _repository.SaveAsync(user);
        
        await _emailService.SendWelcomeEmailAsync(user);
        _logger.Info($"User created: {user.Email}");
        
        return CreateUserResult.Success(user);
    }
}
```

#### Open/Closed Principle (OCP)

```csharp
// 拡張に開いていて、修正に閉じている設計
public abstract class PaymentProcessor
{
    public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request)
    {
        // 共通の前処理
        if (!await ValidateRequestAsync(request))
            return PaymentResult.ValidationFailed();
            
        // 具体的な処理は派生クラスに委譲
        var result = await ProcessPaymentInternalAsync(request);
        
        // 共通の後処理
        await LogPaymentResultAsync(request, result);
        
        return result;
    }
    
    protected abstract Task<PaymentResult> ProcessPaymentInternalAsync(PaymentRequest request);
}

// 新しい決済方法を追加(既存コードの修正不要)
public class ApplePayProcessor : PaymentProcessor
{
    protected override async Task<PaymentResult> ProcessPaymentInternalAsync(PaymentRequest request)
    {
        // Apple Pay固有の処理
        var applePayResult = await _applePayService.ProcessAsync(request.ApplePayToken);
        return applePayResult.IsSuccess 
            ? PaymentResult.Success(applePayResult.TransactionId)
            : PaymentResult.Failed(applePayResult.ErrorMessage);
    }
}
```

## 4.4 関数型プログラミングの活用

### 4.4.1 関数型プログラミングの特徴

関数型プログラミングは、計算を数学的な関数の評価として捉え、状態変更や可変データを避けるパラダイムである。

#### 不変性(Immutability)

```csharp
// 可変オブジェクト(関数型でない例)
public class MutableOrder
{
    public List<OrderItem> Items { get; set; } = new();
    public decimal Total { get; set; }
    
    public void AddItem(OrderItem item)
    {
        Items.Add(item);  // 既存の状態を変更
        RecalculateTotal();
    }
    
    private void RecalculateTotal()
    {
        Total = Items.Sum(item => item.Price * item.Quantity);
    }
}

// 不変オブジェクト(関数型スタイル)
public record ImmutableOrder(ImmutableList<OrderItem> Items)
{
    public decimal Total => Items.Sum(item => item.Price * item.Quantity);
    
    public ImmutableOrder AddItem(OrderItem item)
    {
        return this with { Items = Items.Add(item) };  // 新しいインスタンスを返す
    }
    
    public ImmutableOrder RemoveItem(OrderItem item)
    {
        return this with { Items = Items.Remove(item) };
    }
}

// 使用例
var order = new ImmutableOrder(ImmutableList<OrderItem>.Empty);
var orderWithItem1 = order.AddItem(new OrderItem("Product A", 100, 2));
var orderWithItem2 = orderWithItem1.AddItem(new OrderItem("Product B", 50, 1));

// 元のorderは変更されていない
Console.WriteLine($"Original order total: {order.Total}");      // 0
Console.WriteLine($"Final order total: {orderWithItem2.Total}"); // 250
```

#### 純粋関数(Pure Functions)

```csharp
// 純粋関数:同じ入力に対して常に同じ出力、副作用なし
public static class PureFunctions
{
    public static decimal CalculateTax(decimal amount, decimal taxRate)
    {
        return amount * taxRate;  // 外部状態に依存せず、副作用もない
    }
    
    public static IEnumerable<T> Filter<T>(IEnumerable<T> items, Func<T, bool> predicate)
    {
        foreach (var item in items)
        {
            if (predicate(item))
                yield return item;
        }
    }
    
    public static TResult Map<TInput, TResult>(TInput input, Func<TInput, TResult> mapper)
    {
        return mapper(input);
    }
}

// 非純粋関数の例(避けるべき)
public class ImpureFunctions
{
    private static decimal _globalTaxRate = 0.1m;  // グローバル状態
    
    public static decimal CalculateTaxImpure(decimal amount)
    {
        // 外部状態に依存(テスト困難、予測困難)
        return amount * _globalTaxRate;
    }
    
    public static void LogCalculation(decimal amount, decimal result)
    {
        // 副作用(ファイル出力)
        File.AppendAllText("calculations.log", $"{amount} -> {result}\n");
    }
}
```

#### 高階関数(Higher-Order Functions)

```csharp
public static class HigherOrderFunctions
{
    // 関数を引数として受け取る高階関数
    public static IEnumerable<TResult> MapMany<TInput, TResult>(
        IEnumerable<TInput> inputs,
        Func<TInput, TResult> mapper)
    {
        return inputs.Select(mapper);
    }
    
    // 関数を返す高階関数
    public static Func<decimal, decimal> CreateTaxCalculator(decimal taxRate)
    {
        return amount => amount * taxRate;
    }
    
    // 関数を合成する高階関数
    public static Func<T, TResult> Compose<T, TIntermediate, TResult>(
        Func<T, TIntermediate> first,
        Func<TIntermediate, TResult> second)
    {
        return input => second(first(input));
    }
}

// 使用例
var calculateVAT = HigherOrderFunctions.CreateTaxCalculator(0.2m);
var calculateWithDiscount = (decimal price) => price * 0.9m;

// 関数の合成
var calculateFinalPrice = HigherOrderFunctions.Compose(
    calculateWithDiscount,
    calculateVAT);

var finalPrice = calculateFinalPrice(100m);  // (100 * 0.9) * 1.2 = 108
```

### 4.4.2 関数型パターンの実装

#### Option/Maybe パターン

```csharp
// Nullableの代替:より明示的なOption型
public abstract class Option<T>
{
    public abstract bool HasValue { get; }
    public abstract T Value { get; }
    
    public abstract TResult Match<TResult>(
        Func<T, TResult> onSome,
        Func<TResult> onNone);
}

public class Some<T> : Option<T>
{
    private readonly T _value;
    
    public Some(T value)
    {
        _value = value ?? throw new ArgumentNullException(nameof(value));
    }
    
    public override bool HasValue => true;
    public override T Value => _value;
    
    public override TResult Match<TResult>(Func<T, TResult> onSome, Func<TResult> onNone)
    {
        return onSome(_value);
    }
}

public class None<T> : Option<T>
{
    public override bool HasValue => false;
    public override T Value => throw new InvalidOperationException("None has no value");
    
    public override TResult Match<TResult>(Func<T, TResult> onSome, Func<TResult> onNone)
    {
        return onNone();
    }
}

// 拡張メソッド
public static class OptionExtensions
{
    public static Option<T> Some<T>(T value) => new Some<T>(value);
    public static Option<T> None<T>() => new None<T>();
    
    public static Option<TResult> Map<T, TResult>(
        this Option<T> option,
        Func<T, TResult> mapper)
    {
        return option.Match(
            onSome: value => Some(mapper(value)),
            onNone: () => None<TResult>());
    }
    
    public static Option<TResult> FlatMap<T, TResult>(
        this Option<T> option,
        Func<T, Option<TResult>> mapper)
    {
        return option.Match(
            onSome: mapper,
            onNone: () => None<TResult>());
    }
}

// 使用例
public class CustomerService
{
    public Option<Customer> FindCustomerById(int customerId)
    {
        var customer = _repository.FindById(customerId);
        return customer != null 
            ? OptionExtensions.Some(customer)
            : OptionExtensions.None<Customer>();
    }
    
    public Option<string> GetCustomerEmail(int customerId)
    {
        return FindCustomerById(customerId)
            .Map(customer => customer.Email);
    }
    
    public string GetCustomerEmailOrDefault(int customerId, string defaultEmail)
    {
        return GetCustomerEmail(customerId)
            .Match(
                onSome: email => email,
                onNone: () => defaultEmail);
    }
}
```

#### Result パターン

```csharp
// エラーハンドリングのための関数型パターン
public abstract class Result<TSuccess, TError>
{
    public abstract bool IsSuccess { get; }
    public abstract bool IsFailure { get; }
    
    public abstract TResult Match<TResult>(
        Func<TSuccess, TResult> onSuccess,
        Func<TError, TResult> onFailure);
}

public class Success<TSuccess, TError> : Result<TSuccess, TError>
{
    public TSuccess Value { get; }
    
    public Success(TSuccess value)
    {
        Value = value;
    }
    
    public override bool IsSuccess => true;
    public override bool IsFailure => false;
    
    public override TResult Match<TResult>(
        Func<TSuccess, TResult> onSuccess,
        Func<TError, TResult> onFailure)
    {
        return onSuccess(Value);
    }
}

public class Failure<TSuccess, TError> : Result<TSuccess, TError>
{
    public TError Error { get; }
    
    public Failure(TError error)
    {
        Error = error;
    }
    
    public override bool IsSuccess => false;
    public override bool IsFailure => true;
    
    public override TResult Match<TResult>(
        Func<TSuccess, TResult> onSuccess,
        Func<TError, TResult> onFailure)
    {
        return onFailure(Error);
    }
}

// 実際の使用例
public class OrderService
{
    public async Task<Result<Order, OrderError>> CreateOrderAsync(CreateOrderRequest request)
    {
        return await ValidateRequest(request)
            .FlatMapAsync(async validRequest => await CreateOrderFromRequest(validRequest))
            .FlatMapAsync(async order => await ProcessPayment(order))
            .FlatMapAsync(async order => await ReserveInventory(order));
    }
    
    private Result<CreateOrderRequest, OrderError> ValidateRequest(CreateOrderRequest request)
    {
        if (request.Items == null || !request.Items.Any())
            return new Failure<CreateOrderRequest, OrderError>(
                new OrderError("Order must contain at least one item"));
                
        if (request.CustomerId <= 0)
            return new Failure<CreateOrderRequest, OrderError>(
                new OrderError("Valid customer ID is required"));
                
        return new Success<CreateOrderRequest, OrderError>(request);
    }
}

// Result拡張メソッド
public static class ResultExtensions
{
    public static async Task<Result<TNewSuccess, TError>> FlatMapAsync<TSuccess, TNewSuccess, TError>(
        this Result<TSuccess, TError> result,
        Func<TSuccess, Task<Result<TNewSuccess, TError>>> mapper)
    {
        return result.Match(
            onSuccess: async value => await mapper(value),
            onFailure: error => Task.FromResult(new Failure<TNewSuccess, TError>(error)));
    }
}
```

## 4.5 実践演習:パラダイムの使い分け

### 4.5.1 問題分析とパラダイム選択

#### 演習:オンライン注文システムの設計

**要求**:
1. 商品カタログの検索・フィルタリング
2. ショッピングカートの管理
3. 注文処理ワークフロー
4. 在庫管理
5. 決済処理
6. 通知システム

#### 分析とパラダイム選択

**1. 商品カタログ → 宣言型/関数型**
```csharp
public class ProductCatalogService
{
    // 宣言型:データ検索・フィルタリング
    public async Task<IEnumerable<Product>> SearchProductsAsync(ProductSearchCriteria criteria)
    {
        return await _products
            .AsQueryable()
            .Where(BuildSearchFilter(criteria))    // 宣言的フィルタリング
            .OrderBy(BuildSortExpression(criteria)) // 宣言的ソート
            .Skip(criteria.PageSize * criteria.PageNumber)
            .Take(criteria.PageSize)
            .ToListAsync();
    }
    
    // 関数型:複雑なフィルタ条件の組み合わせ
    private Expression<Func<Product, bool>> BuildSearchFilter(ProductSearchCriteria criteria)
    {
        var filters = new List<Expression<Func<Product, bool>>>();
        
        if (!string.IsNullOrEmpty(criteria.SearchTerm))
            filters.Add(p => p.Name.Contains(criteria.SearchTerm) || 
                            p.Description.Contains(criteria.SearchTerm));
                            
        if (criteria.CategoryId.HasValue)
            filters.Add(p => p.CategoryId == criteria.CategoryId.Value);
            
        if (criteria.MinPrice.HasValue)
            filters.Add(p => p.Price >= criteria.MinPrice.Value);
            
        if (criteria.MaxPrice.HasValue)
            filters.Add(p => p.Price <= criteria.MaxPrice.Value);
            
        return filters.Aggregate((left, right) => left.And(right));
    }
}
```

**2. ショッピングカート → オブジェクト指向 + 関数型**
```csharp
// オブジェクト指向:カートの振る舞いをカプセル化
public class ShoppingCart
{
    private readonly Dictionary<ProductId, CartItem> _items = new();
    
    public IReadOnlyCollection<CartItem> Items => _items.Values;
    
    // 関数型:不変操作でアイテム追加
    public ShoppingCart AddItem(Product product, int quantity)
    {
        var newItems = new Dictionary<ProductId, CartItem>(_items);
        
        if (newItems.TryGetValue(product.Id, out var existingItem))
        {
            newItems[product.Id] = existingItem with { Quantity = existingItem.Quantity + quantity };
        }
        else
        {
            newItems[product.Id] = new CartItem(product, quantity);
        }
        
        return new ShoppingCart(newItems);
    }
    
    // 関数型:価格計算
    public Money CalculateTotal()
    {
        return Items
            .Select(item => item.Product.Price.Multiply(item.Quantity))
            .Aggregate(Money.Zero, (sum, itemTotal) => sum.Add(itemTotal));
    }
}
```

**3. 注文処理 → マルチパラダイム**
```csharp
// 命令型:複雑なワークフロー制御
public class OrderProcessingWorkflow
{
    public async Task<ProcessingResult> ProcessOrderAsync(CreateOrderCommand command)
    {
        try
        {
            // Step 1: バリデーション
            var validationResult = await ValidateOrderAsync(command);
            if (!validationResult.IsValid)
                return ProcessingResult.ValidationFailed(validationResult.Errors);
            
            // Step 2: 注文作成
            var order = await CreateOrderAsync(command);
            
            // Step 3: 在庫引当
            var reservationResult = await ReserveInventoryAsync(order);
            if (!reservationResult.IsSuccess)
                return ProcessingResult.InventoryFailed(reservationResult.Error);
            
            // Step 4: 決済処理
            var paymentResult = await ProcessPaymentAsync(order);
            if (!paymentResult.IsSuccess)
            {
                await ReleaseInventoryAsync(order);  // ロールバック
                return ProcessingResult.PaymentFailed(paymentResult.Error);
            }
            
            // Step 5: 注文確定
            order.Confirm();
            await _orderRepository.SaveAsync(order);
            
            // Step 6: 非同期処理の開始
            await _eventBus.PublishAsync(new OrderConfirmedEvent(order));
            
            return ProcessingResult.Success(order);
        }
        catch (Exception ex)
        {
            _logger.Error(ex, "Order processing failed for command {@Command}", command);
            return ProcessingResult.SystemError(ex.Message);
        }
    }
}

// 宣言型:イベント処理
public class OrderEventHandler
{
    private readonly Dictionary<Type, Func<object, Task>> _handlers;
    
    public OrderEventHandler()
    {
        _handlers = new Dictionary<Type, Func<object, Task>>
        {
            [typeof(OrderConfirmedEvent)] = async e => await HandleOrderConfirmed((OrderConfirmedEvent)e),
            [typeof(PaymentCompletedEvent)] = async e => await HandlePaymentCompleted((PaymentCompletedEvent)e),
            [typeof(OrderShippedEvent)] = async e => await HandleOrderShipped((OrderShippedEvent)e)
        };
    }
    
    public async Task HandleAsync(object eventData)
    {
        if (_handlers.TryGetValue(eventData.GetType(), out var handler))
        {
            await handler(eventData);
        }
    }
}
```

### 4.5.2 パフォーマンスとパラダイムの選択

#### 高性能が要求される場面での選択

```csharp
// 大量データ処理:命令型 + 最適化
public class HighPerformanceDataProcessor
{
    public unsafe void ProcessLargeDataSet(Span<double> data, double multiplier)
    {
        // 命令型:直接的なメモリ操作
        fixed (double* ptr = data)
        {
            for (int i = 0; i < data.Length; i++)
            {
                ptr[i] *= multiplier;
            }
        }
    }
    
    // SIMD(Single Instruction, Multiple Data)の活用
    public void ProcessDataWithSIMD(Span<float> data, float multiplier)
    {
        var vectorMultiplier = new Vector<float>(multiplier);
        var vectorSize = Vector<float>.Count;
        
        int i = 0;
        // ベクトル化された処理
        for (; i <= data.Length - vectorSize; i += vectorSize)
        {
            var vector = new Vector<float>(data.Slice(i, vectorSize));
            vector *= vectorMultiplier;
            vector.CopyTo(data.Slice(i, vectorSize));
        }
        
        // 残りの要素を処理
        for (; i < data.Length; i++)
        {
            data[i] *= multiplier;
        }
    }
}

// 通常の処理:宣言型で可読性重視
public class StandardDataProcessor
{
    public IEnumerable<double> ProcessData(IEnumerable<double> data, double multiplier)
    {
        return data.Select(value => value * multiplier);
    }
    
    // 並列処理:関数型 + 並列実行
    public IEnumerable<ProcessResult> ProcessDataParallel(IEnumerable<DataItem> items)
    {
        return items
            .AsParallel()
            .WithDegreeOfParallelism(Environment.ProcessorCount)
            .Select(ProcessSingleItem)
            .Where(result => result.IsSuccess);
    }
}
```

## まとめ

第4章では、マルチパラダイムプログラミングの重要性と実践方法を学んだ。現代のソフトウェア開発では、単一のパラダイムに固執するのではなく、問題の性質に応じて最適なパラダイムを選択し、組み合わせることが重要である。

### 重要なポイント

1. **問題に応じたパラダイム選択**:データ処理は宣言型、複雑な制御は命令型、概念モデリングはオブジェクト指向
2. **パラダイムの組み合わせ**:一つのシステム内で複数のパラダイムを効果的に組み合わせる
3. **意図の表現**:How よりも What を重視し、意図を明確に表現する
4. **継続的な学習**:新しいパラダイムや言語機能を積極的に取り入れる

次章では、オブジェクト指向設計の真髄について、より深く掘り下げて学ぶ。SOLID原則、デザインパターン、ドメイン駆動設計などの高度な設計技法を通して、保守性と拡張性を兼ね備えたソフトウェアアーキテクチャの構築方法を理解していく。