# 第3章 モデリングとしてのプログラミング

![第3章バナー](../Images/chapter-03-banner.svg)

## 章の概要

### この章の目的
プログラミングを単なる「コンピュータへの指示記述」から「知的なモデリング活動」へと認識を転換し、設計・実装・テストを統合した検証可能なモデル構築スキルを習得する。現実世界の複雑さを適切に抽象化し、保守性の高いソフトウェアモデルを構築する能力を身につける。

### この章で学べること
- 「ソースコードを書く」行為の真の定義:設計+実装+テスト
- 検証可能な設計/実装モデルとしてのソースコードの理解
- 関心の分離による複雑さの管理技法
- 抽象化と具体化の適切なバランス調整
- ドメインモデルとコードの対応関係の構築
- Why-What-How思考法による段階的問題解決
- モデル駆動設計の実践的なアプローチ

### モデリング思考がもたらす革命的変化
多くのプログラマが「仕様書通りにコードを書く」という受動的な姿勢に留まっている。しかし、真のプログラミングは能動的なモデリング活動である。この章で習得するモデリング思考は、あなたの問題解決能力を根本的に変革する。複雑な業務要求を整理された概念モデルに変換し、それを検証可能なコードとして実現する──この一連のプロセスを身につけることで、プログラマから設計者へと成長することができる。

---

プログラミングの本質は**モデリング**である。本章では、プログラミングを単なるコード作成活動ではなく、現実世界の問題や概念をソフトウェアモデルとして表現する知的活動として理解する。

![モデリングとしてのプログラミング概念図](../Images/modeling-programming-concepts.md)

## 3.1 プログラミングは設計+実装+テスト

### 3.1.1 従来の認識との違い

従来、プログラミングは「コンピュータに対する指示の記述」と考えられがちであった。しかし、プログラミングは以下の統合的な活動である:

> 「ソースコードを書く」という行為は**設計+実装+テスト**である

この定義は、プログラミングを単なるコーディング作業から、知的設計活動へと位置づけ直すものである。

### 3.1.2 検証可能な設計/実装モデル

ソースコードは「**検証可能な設計/実装モデル**」である。これは以下の特徴を持つ:

#### 設計としての側面
- **意図の表現**:何を実現したいかを明確に示す
- **構造の定義**:コンポーネント間の関係を定義する
- **責務の分担**:各要素の役割を明確にする

#### 実装としての側面
- **動作の記述**:具体的な振る舞いを定義する
- **実行可能性**:コンピュータが処理できる形式
- **効率性の考慮**:パフォーマンス要件への対応

#### テストとしての側面
- **検証可能性**:正しさを確認できる
- **予測可能性**:期待される結果を明確に定義
- **回帰可能性**:変更後も正しく動作することを保証

_[C#]_
```csharp
// 設計+実装+テストの統合例
public class OrderTotalCalculator  // 設計:責務を明確に定義
{
    // 設計:税計算のルールを明確に表現
    public decimal CalculateTotal(Order order, TaxRate taxRate)
    {
        // 実装:具体的な計算ロジック
        var subtotal = order.Items.Sum(item => item.Price * item.Quantity);
        var tax = subtotal * taxRate.Rate;
        var total = subtotal + tax;
       
        // テスト可能性:結果の妥当性を検証できる構造
        if (total < 0)
            throw new InvalidOperationException("Total cannot be negative");
           
        return total;
    }
}

// テストによる検証
[Test]
public void CalculateTotal_ValidOrder_ReturnsCorrectTotal()
{
    // 設計の意図をテストで検証
    var calculator = new OrderTotalCalculator();
    var order = new Order
    {
        Items = new[] { new OrderItem { Price = 100, Quantity = 2 } }
    };
    var taxRate = new TaxRate { Rate = 0.1m };
   
    var result = calculator.CalculateTotal(order, taxRate);
   
    // 期待される振る舞いを検証
    Assert.AreEqual(220m, result); // (100 * 2) + (200 * 0.1) = 220
}
```

### 3.1.3 プログラミング言語の役割

プログラミング言語は「**モデルを書くのに適した言語**」でなければならない。これは以下の要件を含む:

#### 表現力
_[C#]_
```csharp
// 宣言的な表現:意図が明確
var activeCustomers = customers
    .Where(customer => customer.IsActive)
    .OrderBy(customer => customer.Name);

// vs 手続き的な表現:意図が実装詳細に埋もれる
List<Customer> activeCustomers = new List<Customer>();
for (int i = 0; i < customers.Count; i++)
{
    if (customers[i].IsActive)
    {
        activeCustomers.Add(customers[i]);
    }
}
// ソート処理...
```

#### 抽象化レベルの選択
_[C#]_
```csharp
// 高レベルの抽象化:ビジネス概念を直接表現
public class CustomerLoyaltyService
{
    public LoyaltyLevel CalculateLoyaltyLevel(Customer customer)
    {
        return customer.PurchaseHistory
            .GroupBy(p => p.Date.Year)
            .Select(g => new { Year = g.Key, Amount = g.Sum(p => p.Amount) })
            .OrderByDescending(y => y.Year)
            .Take(3)
            .Average(y => y.Amount) switch
            {
                >= 100000 => LoyaltyLevel.Platinum,
                >= 50000  => LoyaltyLevel.Gold,
                >= 10000  => LoyaltyLevel.Silver,
                _         => LoyaltyLevel.Bronze
            };
    }
}
```

## 3.2 関心の分離とモデル化

### 3.2.1 Separation of Concernsの原理

関心の分離(Separation of Concerns)は、モデリングの基本原理である。複雑なシステムから特定の関心事を切り出し、それぞれを独立して扱うことで複雑さを管理する。

### 3.2.2 関心事の特定と分離

#### 例:ECサイトの注文処理

注文処理という複雑な処理を関心事ごとに分離する:

_[C#]_
```csharp
// 関心事が混在した悪い例
public class OrderController
{
    public IActionResult ProcessOrder(OrderRequest request)
    {
        // バリデーションの関心事
        if (string.IsNullOrEmpty(request.CustomerEmail))
            return BadRequest("Email is required");
           
        // データアクセスの関心事
        using var connection = new SqlConnection(connectionString);
        connection.Open();
       
        // ビジネスルールの関心事
        var discount = request.TotalAmount > 10000 ? 0.1m : 0;
       
        // 外部サービス連携の関心事
        var paymentResult = CallPaymentAPI(request.PaymentInfo);
       
        // ログ出力の関心事
        _logger.Info($"Order processed: {request.OrderId}");
       
        return Ok();
    }
}
```

_[C#]_
```csharp
// 関心事を分離した良い例
public class OrderController
{
    private readonly IOrderService _orderService;
   
    public async Task<IActionResult> ProcessOrder(OrderRequest request)
    {
        var result = await _orderService.ProcessOrderAsync(request);
        return result.IsSuccess ? Ok(result.Order) : BadRequest(result.ErrorMessage);
    }
}

// 各関心事を独立したクラスで実装
public class OrderService : IOrderService
{
    private readonly IOrderValidator _validator;      // バリデーション
    private readonly IOrderRepository _repository;    // データアクセス
    private readonly IPricingService _pricingService; // ビジネスルール
    private readonly IPaymentService _paymentService; // 外部連携
    private readonly ILogger _logger;                 // ログ出力
   
    public async Task<OrderProcessingResult> ProcessOrderAsync(OrderRequest request)
    {
        // 各関心事を順次処理
        var validationResult = await _validator.ValidateAsync(request);
        if (!validationResult.IsValid)
            return OrderProcessingResult.ValidationFailed(validationResult.Errors);
           
        var order = await _pricingService.CalculatePricingAsync(request);
        var paymentResult = await _paymentService.ProcessPaymentAsync(order);
       
        if (paymentResult.IsSuccess)
        {
            await _repository.SaveAsync(order);
            _logger.Info($"Order processed successfully: {order.Id}");
            return OrderProcessingResult.Success(order);
        }
       
        return OrderProcessingResult.PaymentFailed(paymentResult.ErrorMessage);
    }
}
```

### 3.2.3 レイヤー別の関心分離

#### プレゼンテーション層の関心事
- ユーザーインターフェースの制御
- 入力値の基本的なバリデーション
- 表示形式の変換

_[C#]_
```csharp
public class CustomerController
{
    private readonly ICustomerService _customerService;
   
    [HttpPost]
    public async Task<IActionResult> CreateCustomer(CreateCustomerRequest request)
    {
        // プレゼンテーション層の関心事:入力形式の変換
        var command = new CreateCustomerCommand
        {
            Name = request.Name?.Trim(),
            Email = request.Email?.ToLowerInvariant(),
            PhoneNumber = request.PhoneNumber?.Replace("-", "")
        };
       
        var result = await _customerService.CreateCustomerAsync(command);
       
        // プレゼンテーション層の関心事:応答形式の決定
        return result.IsSuccess
            ? CreatedAtAction(nameof(GetCustomer), new { id = result.Customer.Id }, result.Customer)
            : BadRequest(result.ErrorMessage);
    }
}
```

#### ビジネス層の関心事
- ビジネスルールの実装
- ワークフローの制御
- ドメインモデルの管理

_[C#]_
```csharp
public class CustomerService : ICustomerService
{
    private readonly ICustomerRepository _repository;
    private readonly IEmailService _emailService;
    private readonly IDomainEventPublisher _eventPublisher;
   
    public async Task<CreateCustomerResult> CreateCustomerAsync(CreateCustomerCommand command)
    {
        // ビジネス層の関心事:ビジネスルールの適用
        var existingCustomer = await _repository.FindByEmailAsync(command.Email);
        if (existingCustomer != null)
            return CreateCustomerResult.Failure("Customer with this email already exists");
           
        // ビジネス層の関心事:ドメインモデルの構築
        var customer = Customer.Create(command.Name, command.Email, command.PhoneNumber);
       
        await _repository.SaveAsync(customer);
       
        // ビジネス層の関心事:ビジネスイベントの発行
        await _eventPublisher.PublishAsync(new CustomerCreatedEvent(customer));
       
        return CreateCustomerResult.Success(customer);
    }
}
```

#### データ層の関心事
- データの永続化
- データの取得と検索
- トランザクション管理

_[C#]_
```csharp
public class CustomerRepository : ICustomerRepository
{
    private readonly DbContext _context;
   
    public async Task<Customer> FindByEmailAsync(string email)
    {
        // データ層の関心事:効率的なデータ検索
        return await _context.Customers
            .Where(c => c.Email == email)
            .FirstOrDefaultAsync();
    }
   
    public async Task SaveAsync(Customer customer)
    {
        // データ層の関心事:適切なデータ永続化
        if (customer.Id == 0)
            _context.Customers.Add(customer);
        else
            _context.Customers.Update(customer);
           
        await _context.SaveChangesAsync();
    }
}
```

### 3.2.4 時間軸による関心分離

関心事は機能だけでなく、時間軸でも分離できる:

_[C#]_
```csharp
// 同期処理の関心事
public class OrderService
{
    public async Task<Order> CreateOrderAsync(CreateOrderCommand command)
    {
        // 即座に必要な処理のみを実行
        var order = Order.Create(command.CustomerId, command.Items);
        await _repository.SaveAsync(order);
       
        // 非同期処理への移譲
        await _eventPublisher.PublishAsync(new OrderCreatedEvent(order));
       
        return order;
    }
}

// 非同期処理の関心事
public class OrderCreatedEventHandler : IEventHandler<OrderCreatedEvent>
{
    public async Task HandleAsync(OrderCreatedEvent eventData)
    {
        // 時間のかかる処理を非同期で実行
        await _inventoryService.ReserveItemsAsync(eventData.Order);
        await _emailService.SendOrderConfirmationAsync(eventData.Order);
        await _analyticsService.RecordOrderAsync(eventData.Order);
    }
}
```

## 3.3 抽象化と具体化のバランス

### 3.3.1 適切な抽象化レベル

モデリングにおいて、適切な抽象化レベルを選択することが重要である。過度な抽象化は理解を困難にし、不十分な抽象化は重複と複雑さを生む。

#### 抽象化の階層

_[C#]_
```csharp
// 最高レベルの抽象化:インターフェース
public interface IPaymentProcessor
{
    Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request);
}

// 中レベルの抽象化:抽象クラス
public abstract class PaymentProcessorBase : IPaymentProcessor
{
    protected readonly ILogger _logger;
    protected readonly IPaymentValidator _validator;
   
    protected PaymentProcessorBase(ILogger logger, IPaymentValidator validator)
    {
        _logger = logger;
        _validator = validator;
    }
   
    public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request)
    {
        // 共通の処理フロー
        _logger.Info($"Processing payment: {request.Amount}");
       
        var validationResult = await _validator.ValidateAsync(request);
        if (!validationResult.IsValid)
            return PaymentResult.ValidationFailed(validationResult.Errors);
           
        return await ProcessPaymentInternalAsync(request);
    }
   
    // 具体的な実装は派生クラスに委譲
    protected abstract Task<PaymentResult> ProcessPaymentInternalAsync(PaymentRequest request);
}

// 具体的な実装:特定の決済方法
public class CreditCardPaymentProcessor : PaymentProcessorBase
{
    private readonly ICreditCardService _creditCardService;
   
    public CreditCardPaymentProcessor(
        ILogger logger,
        IPaymentValidator validator,
        ICreditCardService creditCardService) : base(logger, validator)
    {
        _creditCardService = creditCardService;
    }
   
    protected override async Task<PaymentResult> ProcessPaymentInternalAsync(PaymentRequest request)
    {
        // クレジットカード特有の処理
        var cardInfo = (CreditCardInfo)request.PaymentMethod;
        return await _creditCardService.ChargeAsync(cardInfo, request.Amount);
    }
}
```

### 3.3.2 具体性と抽象性のバランス

#### 過度な抽象化の問題

_[C#]_
```csharp
// 過度に抽象的で理解困難
public interface IGenericProcessor<TInput, TOutput, TContext>
{
    Task<IResult<TOutput>> ProcessAsync(TInput input, TContext context, IProcessingOptions options);
}

public class GenericBusinessLogicProcessor<TEntity, TResult, TContext>
    : IGenericProcessor<TEntity, TResult, TContext>
{
    // 抽象的すぎて具体的な用途が不明
}
```

_[C#]_
```csharp
// 適切なレベルの抽象化
public interface IOrderProcessor
{
    Task<OrderProcessingResult> ProcessOrderAsync(Order order);
}

public class StandardOrderProcessor : IOrderProcessor
{
    public async Task<OrderProcessingResult> ProcessOrderAsync(Order order)
    {
        // 具体的で理解しやすい実装
        await ValidateOrder(order);
        await CalculatePricing(order);
        await ProcessPayment(order);
        await UpdateInventory(order);
       
        return OrderProcessingResult.Success(order);
    }
}
```

#### 不十分な抽象化の問題

_[C#]_
```csharp
// 重複が多く、変更が困難
public class CreditCardOrderProcessor
{
    public async Task ProcessCreditCardOrder(Order order)
    {
        // 共通処理
        ValidateOrder(order);
        CalculatePricing(order);
       
        // クレジットカード固有の処理
        await ProcessCreditCardPayment(order);
       
        // 共通処理
        UpdateInventory(order);
        SendConfirmationEmail(order);
    }
}

public class PayPalOrderProcessor
{
    public async Task ProcessPayPalOrder(Order order)
    {
        // 重複した共通処理
        ValidateOrder(order);
        CalculatePricing(order);
       
        // PayPal固有の処理
        await ProcessPayPalPayment(order);
       
        // 重複した共通処理
        UpdateInventory(order);
        SendConfirmationEmail(order);
    }
}
```

_[C#]_
```csharp
// 適切な抽象化による改善
public class OrderProcessor
{
    private readonly IPaymentProcessorFactory _paymentProcessorFactory;
   
    public async Task<OrderProcessingResult> ProcessOrderAsync(Order order)
    {
        // 共通処理を一箇所に集約
        ValidateOrder(order);
        CalculatePricing(order);
       
        // 決済方法に応じた処理を抽象化
        var paymentProcessor = _paymentProcessorFactory.Create(order.PaymentMethod);
        var paymentResult = await paymentProcessor.ProcessPaymentAsync(order);
       
        if (paymentResult.IsSuccess)
        {
            UpdateInventory(order);
            SendConfirmationEmail(order);
            return OrderProcessingResult.Success(order);
        }
       
        return OrderProcessingResult.PaymentFailed(paymentResult.ErrorMessage);
    }
}
```

### 3.3.3 段階的な抽象化

複雑なシステムでは、段階的に抽象化レベルを上げていくアプローチが有効である:

_[C#]_
```csharp
// Level 1: 具体的な実装
public class EmailNotificationSender
{
    public async Task SendWelcomeEmail(Customer customer)
    {
        var smtpClient = new SmtpClient("smtp.company.com");
        var message = new MailMessage(
            "welcome@company.com",
            customer.Email,
            "Welcome!",
            $"Hello {customer.Name}, welcome to our service!");
        await smtpClient.SendMailAsync(message);
    }
}

// Level 2: 単一責務への分離
public class EmailNotificationSender
{
    private readonly IEmailClient _emailClient;
    private readonly IEmailTemplateService _templateService;
   
    public async Task SendWelcomeEmail(Customer customer)
    {
        var emailContent = _templateService.GetWelcomeEmailContent(customer);
        await _emailClient.SendAsync(emailContent);
    }
}

// Level 3: より高い抽象化
public class NotificationService
{
    private readonly INotificationChannelFactory _channelFactory;
   
    public async Task SendWelcomeNotification(Customer customer)
    {
        var channels = _channelFactory.GetChannelsForCustomer(customer);
        var welcomeMessage = CreateWelcomeMessage(customer);
       
        await Task.WhenAll(channels.Select(channel =>
            channel.SendAsync(welcomeMessage)));
    }
}

// Level 4: イベント駆動による疎結合
public class CustomerService
{
    private readonly IDomainEventPublisher _eventPublisher;
   
    public async Task CreateCustomerAsync(CreateCustomerCommand command)
    {
        var customer = Customer.Create(command.Name, command.Email);
        await _repository.SaveAsync(customer);
       
        // 通知の詳細は他の関心事に委譲
        await _eventPublisher.PublishAsync(new CustomerCreatedEvent(customer));
    }
}
```

## 3.4 ドメインモデルとコードの対応

### 3.4.1 ドメイン駆動設計(DDD)との関連

エリック・エヴァンスのドメイン駆動設計(Domain-Driven Design)は、モデリングとしてのプログラミングを実践するための強力な手法である。

#### ユビキタス言語(Ubiquitous Language)

ドメインエキスパート、開発者、ステークホルダーが共通して使用する言語をコードに反映する:

_[C#]_
```csharp
// ドメインエキスパートが使う用語をそのままコードに反映
public class InsurancePolicy  // 保険証券
{
    public PolicyNumber Number { get; private set; }      // 証券番号
    public Premium MonthlyPremium { get; private set; }   // 月額保険料
    public Coverage Coverage { get; private set; }        // 補償内容
   
    public ClaimAssessmentResult AssessClaim(Claim claim) // 請求査定
    {
        // ビジネスルールをドメインの言葉で表現
        if (claim.IncidentDate < EffectiveDate)
            return ClaimAssessmentResult.Rejected("Incident occurred before policy effective date");
           
        if (claim.Amount > Coverage.MaximumBenefit)
            return ClaimAssessmentResult.PartiallyApproved(Coverage.MaximumBenefit);
           
        return ClaimAssessmentResult.FullyApproved(claim.Amount);
    }
}

// ドメインエキスパートが理解できるビジネスルール
public class PremiumCalculator  // 保険料計算
{
    public Premium CalculateMonthlyPremium(
        Age applicantAge,           // 申込者年齢
        RiskCategory riskCategory,  // リスク区分
        CoverageAmount coverage)    // 補償額
    {
        // 保険業界の専門知識をコードで表現
        var basePremium = coverage.Amount * 0.001m;
        var ageMultiplier = applicantAge.Value switch
        {
            < 30 => 1.0m,
            < 50 => 1.2m,
            < 70 => 1.5m,
            _ => 2.0m
        };
        var riskMultiplier = riskCategory.Multiplier;
       
        return new Premium(basePremium * ageMultiplier * riskMultiplier);
    }
}
```

#### 境界づけられたコンテキスト(Bounded Context)

異なるコンテキストでは同じ用語でも異なる意味を持つ場合がある:

_[C#]_
```csharp
// 販売コンテキストの顧客
namespace Sales
{
    public class Customer
    {
        public CustomerId Id { get; }
        public string Name { get; }
        public ContactInfo ContactInfo { get; }
        public CreditLimit CreditLimit { get; }  // 与信限度額
       
        public Order PlaceOrder(List<Product> products)
        {
            // 販売の観点での顧客の振る舞い
        }
    }
}

// サポートコンテキストの顧客
namespace Support
{
    public class Customer
    {
        public CustomerId Id { get; }
        public string Name { get; }
        public ContactInfo ContactInfo { get; }
        public SupportLevel SupportLevel { get; }  // サポートレベル
        public List<Ticket> OpenTickets { get; }   // 未解決チケット
       
        public Ticket CreateSupportTicket(string issue)
        {
            // サポートの観点での顧客の振る舞い
        }
    }
}
```

### 3.4.2 ドメインモデルの表現パターン

#### Value Object(値オブジェクト)

不変で、同等性が値によって決まるオブジェクト:

_[C#]_
```csharp
public class Money  // 金額という概念を適切にモデル化
{
    public decimal Amount { get; }
    public Currency Currency { get; }
   
    public Money(decimal amount, Currency currency)
    {
        if (amount < 0)
            throw new ArgumentException("Amount cannot be negative");
        Amount = amount;
        Currency = currency;
    }
   
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
        return new Money(Amount + other.Amount, Currency);
    }
   
    // 値による同等性
    public override bool Equals(object obj)
    {
        return obj is Money money &&
               Amount == money.Amount &&
               Currency == money.Currency;
    }
   
    public override int GetHashCode() => HashCode.Combine(Amount, Currency);
}

public class EmailAddress  // メールアドレスという概念を型安全にモデル化
{
    public string Value { get; }
   
    public EmailAddress(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Email address cannot be empty");
        if (!IsValidEmailFormat(value))
            throw new ArgumentException("Invalid email format");
        Value = value.ToLowerInvariant();
    }
   
    private static bool IsValidEmailFormat(string email)
    {
        return System.Text.RegularExpressions.Regex.IsMatch(email, @"^[^@\s]+@[^@\s]+\.[^@\s]+$");
    }
   
    public static implicit operator string(EmailAddress email) => email.Value;
    public static explicit operator EmailAddress(string email) => new(email);
}
```

#### Entity(エンティティ)

一意のアイデンティティを持つオブジェクト:

_[C#]_
```csharp
public class Customer  // 顧客エンティティ
{
    public CustomerId Id { get; private set; }  // 一意の識別子
    public string Name { get; private set; }
    public EmailAddress Email { get; private set; }
    public CustomerStatus Status { get; private set; }
   
    // ファクトリメソッド:適切な初期状態を保証
    public static Customer Create(string name, EmailAddress email)
    {
        return new Customer
        {
            Id = CustomerId.NewId(),
            Name = name,
            Email = email,
            Status = CustomerStatus.Active
        };
    }
   
    // ドメインの振る舞い:ビジネスルールを内包
    public void Deactivate(DeactivationReason reason)
    {
        if (Status == CustomerStatus.Inactive)
            throw new InvalidOperationException("Customer is already inactive");
           
        Status = CustomerStatus.Inactive;
        // ドメインイベントの発行
        DomainEvents.Raise(new CustomerDeactivatedEvent(this, reason));
    }
   
    // エンティティの同等性はIDによって決まる
    public override bool Equals(object obj)
    {
        return obj is Customer customer && Id.Equals(customer.Id);
    }
   
    public override int GetHashCode() => Id.GetHashCode();
}
```

#### Aggregate(集約)

整合性の境界を定義するエンティティのクラスター:

_[C#]_
```csharp
public class Order  // 注文集約のルート
{
    private readonly List<OrderItem> _items = new();
   
    public OrderId Id { get; private set; }
    public CustomerId CustomerId { get; private set; }
    public Money Total => _items.Select(item => item.LineTotal).Aggregate(Money.Zero, (a, b) => a.Add(b));
    public OrderStatus Status { get; private set; }
    public IReadOnlyList<OrderItem> Items => _items.AsReadOnly();
   
    public static Order Create(CustomerId customerId)
    {
        return new Order
        {
            Id = OrderId.NewId(),
            CustomerId = customerId,
            Status = OrderStatus.Draft
        };
    }
   
    // 集約内の整合性を保つ操作
    public void AddItem(Product product, int quantity)
    {
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Cannot modify confirmed order");
           
        var existingItem = _items.FirstOrDefault(item => item.ProductId == product.Id);
        if (existingItem != null)
        {
            existingItem.UpdateQuantity(existingItem.Quantity + quantity);
        }
        else
        {
            _items.Add(new OrderItem(product.Id, product.Price, quantity));
        }
    }
   
    public void Confirm()
    {
        if (!_items.Any())
            throw new InvalidOperationException("Cannot confirm order without items");
        if (Status != OrderStatus.Draft)
            throw new InvalidOperationException("Order is already confirmed");
           
        Status = OrderStatus.Confirmed;
        DomainEvents.Raise(new OrderConfirmedEvent(this));
    }
}
```

### 3.4.3 ドメインサービス

複数のエンティティにまたがるドメインロジックを実装:

_[C#]_
```csharp
public class TransferService  // 送金ドメインサービス
{
    public TransferResult Transfer(
        Account fromAccount,
        Account toAccount,
        Money amount)
    {
        // 複数のエンティティに関わるビジネスルール
        if (fromAccount.Currency != amount.Currency)
            return TransferResult.Failed("Currency mismatch");
           
        if (!fromAccount.CanWithdraw(amount))
            return TransferResult.Failed("Insufficient funds");
           
        if (toAccount.IsBlocked)
            return TransferResult.Failed("Destination account is blocked");
           
        // 両方のアカウントに対する操作をアトミックに実行
        fromAccount.Withdraw(amount);
        toAccount.Deposit(amount);
       
        return TransferResult.Success(
            new TransferRecord(fromAccount.Id, toAccount.Id, amount));
    }
}
```

## 3.5 実践演習:モデル駆動設計

### 3.5.1 Why-What-How思考法の適用

モデル駆動設計を実践する際、問題を段階的に整理し、各レベルで適切な抽象化を行う思考法が重要である。Why-What-How思考法は、この段階的な問題解決に効果的なフレームワークを提供する。

![Why-What-How 思考法による段階的問題解決](../Images/why-what-how-thinking.md)

### 3.5.2 要求分析からモデルへの変換

#### 演習:図書館システムの設計

**要求**:
- 図書館には多数の書籍がある
- 利用者は書籍を借りることができる
- 書籍には貸出期限がある
- 延滞した場合は延滞料が発生する
- 人気のある書籍は予約ができる

#### Step 1: ドメインエキスパートへのインタビュー

**質問例**:
- 「貸出」とは具体的にどのような行為ですか?
- 延滞料はどのように計算されますか?
- 予約の優先順位はありますか?
- 同じ書籍の複数の冊数がある場合の扱いは?

#### Step 2: ユビキタス言語の確立

_[C#]_
```csharp
// 図書館ドメインの語彙
public class Book          // 書籍(物理的な本)
public class BookCopy      // 冊(個別の本の実体)
public class Member        // 利用者
public class Loan          // 貸出
public class Reservation   // 予約
public class Fine          // 延滞料
```

#### Step 3: モデルの実装

_[C#]_
```csharp
public class LibraryMember  // 図書館利用者
{
    public MemberId Id { get; private set; }
    public string Name { get; private set; }
    public EmailAddress Email { get; private set; }
    public MembershipStatus Status { get; private set; }
    private readonly List<Loan> _currentLoans = new();
    private readonly List<Fine> _unpaidFines = new();
   
    public LoanResult BorrowBook(BookCopy bookCopy, LoanPeriod period)
    {
        // ビジネスルール:延滞料がある場合は借りられない
        if (_unpaidFines.Any())
            return LoanResult.Failed("Outstanding fines must be paid");
           
        // ビジネスルール:最大貸出冊数の制限
        if (_currentLoans.Count >= MaxLoansAllowed)
            return LoanResult.Failed("Maximum loan limit exceeded");
           
        var loan = Loan.Create(this.Id, bookCopy.Id, period);
        _currentLoans.Add(loan);
       
        return LoanResult.Success(loan);
    }
   
    public ReturnResult ReturnBook(BookCopy bookCopy)
    {
        var loan = _currentLoans.FirstOrDefault(l => l.BookCopyId == bookCopy.Id);
        if (loan == null)
            return ReturnResult.Failed("Book is not currently loaned to this member");
           
        loan.Return();
        _currentLoans.Remove(loan);
       
        // 延滞料の計算
        if (loan.IsOverdue)
        {
            var fine = Fine.Calculate(loan.OverdueDays);
            _unpaidFines.Add(fine);
            return ReturnResult.SuccessWithFine(fine);
        }
       
        return ReturnResult.Success();
    }
}

public class BookCopy  // 書籍の物理的なコピー
{
    public BookCopyId Id { get; private set; }
    public BookId BookId { get; private set; }
    public BookCopyStatus Status { get; private set; }
    public string Location { get; private set; }  // 書架位置
   
    public bool IsAvailableForLoan => Status == BookCopyStatus.Available;
   
    public void LoanTo(MemberId memberId)
    {
        if (!IsAvailableForLoan)
            throw new InvalidOperationException("Book copy is not available for loan");
           
        Status = BookCopyStatus.OnLoan;
        // ドメインイベント
        DomainEvents.Raise(new BookCopyLoanedEvent(Id, memberId));
    }
   
    public void Return()
    {
        if (Status != BookCopyStatus.OnLoan)
            throw new InvalidOperationException("Book copy is not currently on loan");
           
        Status = BookCopyStatus.Available;
        DomainEvents.Raise(new BookCopyReturnedEvent(Id));
    }
}

public class Loan  // 貸出記録
{
    public LoanId Id { get; private set; }
    public MemberId MemberId { get; private set; }
    public BookCopyId BookCopyId { get; private set; }
    public DateTime LoanDate { get; private set; }
    public DateTime DueDate { get; private set; }
    public DateTime? ReturnDate { get; private set; }
   
    public bool IsOverdue => !ReturnDate.HasValue && DateTime.Now > DueDate;
    public int OverdueDays => IsOverdue ? (DateTime.Now - DueDate).Days : 0;
   
    public static Loan Create(MemberId memberId, BookCopyId bookCopyId, LoanPeriod period)
    {
        return new Loan
        {
            Id = LoanId.NewId(),
            MemberId = memberId,
            BookCopyId = bookCopyId,
            LoanDate = DateTime.Now,
            DueDate = DateTime.Now.Add(period.Duration)
        };
    }
   
    public void Return()
    {
        if (ReturnDate.HasValue)
            throw new InvalidOperationException("Book has already been returned");
           
        ReturnDate = DateTime.Now;
    }
}
```

### 3.5.2 モデルの継続的改善

#### 演習:フィードバックに基づく改善

**新しい要求**:
- 電子書籍の対応が必要
- 複数の図書館拠点での相互利用
- 利用者の読書履歴の管理

#### 改善されたモデル

_[C#]_
```csharp
// 書籍の概念を抽象化
public abstract class BookItem
{
    public BookItemId Id { get; protected set; }
    public Book Book { get; protected set; }
    public abstract bool IsAvailableForLoan { get; }
    public abstract LoanResult LoanTo(MemberId memberId, LoanPeriod period);
}

// 物理的な書籍
public class PhysicalBookCopy : BookItem
{
    public Library Location { get; private set; }
    public BookCopyStatus Status { get; private set; }
   
    public override bool IsAvailableForLoan =>
        Status == BookCopyStatus.Available;
       
    public override LoanResult LoanTo(MemberId memberId, LoanPeriod period)
    {
        if (!IsAvailableForLoan)
            return LoanResult.Failed("Physical book is not available");
           
        Status = BookCopyStatus.OnLoan;
        return LoanResult.Success(CreatePhysicalLoan(memberId, period));
    }
}

// 電子書籍
public class EBook : BookItem
{
    public int MaxConcurrentLoans { get; private set; }
    public int CurrentLoans { get; private set; }
   
    public override bool IsAvailableForLoan =>
        CurrentLoans < MaxConcurrentLoans;
       
    public override LoanResult LoanTo(MemberId memberId, LoanPeriod period)
    {
        if (!IsAvailableForLoan)
            return LoanResult.Failed("All digital copies are currently on loan");
           
        CurrentLoans++;
        return LoanResult.Success(CreateDigitalLoan(memberId, period));
    }
}

// 読書履歴の管理
public class ReadingHistory
{
    private readonly List<ReadingRecord> _records = new();
   
    public void RecordBookReturn(Loan loan, Rating? rating = null)
    {
        var record = new ReadingRecord(
            loan.MemberId,
            loan.BookCopyId,
            loan.LoanDate,
            loan.ReturnDate.Value,
            rating);
           
        _records.Add(record);
    }
   
    public IEnumerable<Book> GetRecommendations(MemberId memberId)
    {
        // 読書履歴に基づくレコメンデーション
        var memberHistory = _records.Where(r => r.MemberId == memberId);
        // レコメンデーションアルゴリズムの実装
        return CalculateRecommendations(memberHistory);
    }
}
```

## まとめ

第3章では、プログラミングがモデリング活動であることを学んだ。ソースコードは単なる実装ではなく、現実世界の複雑さを整理し、理解可能な形で表現する「検証可能な設計/実装モデル」である。

### 重要なポイント

1. **プログラミングは設計+実装+テスト**:統合的な知的活動として捉える
2. **関心の分離**:複雑さを管理するための基本原理
3. **適切な抽象化**:過度でも不十分でもない、バランスの取れた抽象化
4. **ドメインモデルの表現**:現実世界の概念をコードで適切に表現する

次章では、現代のプログラミングにおいて重要性を増している「マルチパラダイムプログラミング」について学ぶ。異なるプログラミングパラダイムの特徴を理解し、問題に応じて最適なパラダイムを選択する技法を身につけていく。