# 第7章 リファクタリングと継続的品質改善

## 7.1 リファクタリングの基本原則

### 7.1.1 リファクタリングとは何か

リファクタリングとは、**ソフトウェアの外部的振る舞いを変えることなく、内部構造を改善すること**である。Martin Fowlerが定義したこの概念は、美しいソースコードを維持するための最も重要な実践の一つである。

> 「リファクタリングは、ソフトウェアの内部設計を、外部的振る舞いを変えることなく、理解しやすく、変更しやすくするために変更することである」

#### リファクタリングの目的

1. **理解容易性の向上**: コードの意図をより明確に表現する
2. **変更容易性の向上**: 新機能の追加や仕様変更を容易にする
3. **保守性の向上**: バグの発見と修正を簡単にする
4. **技術的負債の返済**: 設計の劣化を改善する

### 7.1.2 リファクタリングの前提条件

リファクタリングを安全に実行するためには、以下の条件が必要である:

![リファクタリングワークフロー図](Images/refactoring-workflow.md)

#### 包括的なテストスイートの存在

リファクタリングを安全に行うためには、対象コードが包括的なテストでカバーされている必要がある。

```csharp
// リファクタリング前:テストが必要
public class OrderProcessor
{
    public decimal CalculateTotal(Order order)
    {
        decimal total = 0;
        foreach (var item in order.Items)
        {
            if (item.Category == "Electronics")
                total += item.Price * 1.08m; // 消費税8%
            else if (item.Category == "Books")
                total += item.Price * 1.05m; // 軽減税率5%
            else
                total += item.Price * 1.08m;
        }
        return total;
    }
}

// 対応するテスト
[TestClass]
public class OrderProcessorTests
{
    [TestMethod]
    public void CalculateTotal_ElectronicsItems_AppliesStandardTax()
    {
        var order = new Order();
        order.AddItem(new Item("Laptop", 100000, "Electronics"));
        
        var processor = new OrderProcessor();
        var total = processor.CalculateTotal(order);
        
        Assert.AreEqual(108000, total);
    }
    
    [TestMethod]
    public void CalculateTotal_BookItems_AppliesReducedTax()
    {
        var order = new Order();
        order.AddItem(new Item("Programming Book", 3000, "Books"));
        
        var processor = new OrderProcessor();
        var total = processor.CalculateTotal(order);
        
        Assert.AreEqual(3150, total);
    }
    
    [TestMethod]
    public void CalculateTotal_MixedItems_AppliesCorrectTaxes()
    {
        var order = new Order();
        order.AddItem(new Item("Laptop", 100000, "Electronics"));
        order.AddItem(new Item("Programming Book", 3000, "Books"));
        
        var processor = new OrderProcessor();
        var total = processor.CalculateTotal(order);
        
        Assert.AreEqual(111150, total); // 108000 + 3150
    }
}
```

#### 小さな段階的変更

リファクタリングは小さなステップで行い、各ステップ後にテストを実行して回帰がないことを確認する。

### 7.1.3 リファクタリングの基本戦略

#### 重複の除去(DRY原則の適用)

```python
# リファクタリング前:重複がある
class UserValidator:
    def validate_email(self, email):
        if not email:
            print(f"Error: Email is required")
            return False
        if "@" not in email:
            print(f"Error: Invalid email format")
            return False
        return True
    
    def validate_phone(self, phone):
        if not phone:
            print(f"Error: Phone is required")
            return False
        if len(phone) < 10:
            print(f"Error: Phone number too short")
            return False
        return True

# リファクタリング後:重複を除去
class UserValidator:
    def _log_error(self, message):
        print(f"Error: {message}")
    
    def validate_email(self, email):
        if not email:
            self._log_error("Email is required")
            return False
        if "@" not in email:
            self._log_error("Invalid email format")
            return False
        return True
    
    def validate_phone(self, phone):
        if not phone:
            self._log_error("Phone is required")
            return False
        if len(phone) < 10:
            self._log_error("Phone number too short")
            return False
        return True
```

#### 責務の明確化

```java
// リファクタリング前:複数の責務が混在
public class Customer {
    private String name;
    private String email;
    private List<Order> orders;
    
    public void addOrder(Order order) {
        orders.add(order);
    }
    
    public BigDecimal calculateTotalSpent() {
        BigDecimal total = BigDecimal.ZERO;
        for (Order order : orders) {
            total = total.add(order.getTotal());
        }
        return total;
    }
    
    public void sendPromotionalEmail(String content) {
        // メール送信ロジック
        EmailService emailService = new EmailService();
        emailService.sendEmail(this.email, "Promotion", content);
    }
    
    public String generateReport() {
        // レポート生成ロジック
        StringBuilder report = new StringBuilder();
        report.append("Customer: ").append(name).append("\n");
        report.append("Total Spent: ").append(calculateTotalSpent()).append("\n");
        return report.toString();
    }
}

// リファクタリング後:責務を分離
public class Customer {
    private String name;
    private String email;
    private List<Order> orders;
    
    public void addOrder(Order order) {
        orders.add(order);
    }
    
    public BigDecimal calculateTotalSpent() {
        return orders.stream()
                   .map(Order::getTotal)
                   .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    // ゲッター
    public String getName() { return name; }
    public String getEmail() { return email; }
    public List<Order> getOrders() { return new ArrayList<>(orders); }
}

// 分離されたサービス
public class CustomerEmailService {
    private final EmailService emailService;
    
    public CustomerEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
    
    public void sendPromotionalEmail(Customer customer, String content) {
        emailService.sendEmail(customer.getEmail(), "Promotion", content);
    }
}

public class CustomerReportService {
    public String generateReport(Customer customer) {
        StringBuilder report = new StringBuilder();
        report.append("Customer: ").append(customer.getName()).append("\n");
        report.append("Total Spent: ").append(customer.calculateTotalSpent()).append("\n");
        return report.toString();
    }
}
```

## 7.2 コードの臭いと対処法

### 7.2.1 コードの臭い(Code Smells)とは

コードの臭いとは、**コードに問題があることを示すサイン**である。それ自体はバグではないが、設計上の問題や将来のバグの温床となりうる特徴を指す。

### 7.2.2 主要なコードの臭いと対処法

#### 長いメソッド(Long Method)

```csharp
// 悪い例:長すぎるメソッド
public void ProcessOrder(Order order)
{
    // バリデーション
    if (order == null) throw new ArgumentNullException(nameof(order));
    if (order.Items.Count == 0) throw new InvalidOperationException("Order must have items");
    if (string.IsNullOrEmpty(order.CustomerEmail)) throw new InvalidOperationException("Customer email is required");
    
    // 在庫チェック
    foreach (var item in order.Items)
    {
        var inventory = inventoryService.GetInventory(item.ProductId);
        if (inventory.Quantity < item.Quantity)
            throw new InvalidOperationException($"Insufficient inventory for {item.ProductName}");
    }
    
    // 価格計算
    decimal subtotal = 0;
    foreach (var item in order.Items)
    {
        subtotal += item.Price * item.Quantity;
    }
    
    decimal tax = subtotal * 0.08m;
    decimal shipping = subtotal > 5000 ? 0 : 500;
    order.Total = subtotal + tax + shipping;
    
    // 在庫更新
    foreach (var item in order.Items)
    {
        inventoryService.UpdateInventory(item.ProductId, -item.Quantity);
    }
    
    // 支払い処理
    var paymentResult = paymentService.ProcessPayment(order.Total, order.PaymentMethod);
    if (!paymentResult.IsSuccess)
        throw new InvalidOperationException("Payment failed");
    
    // メール送信
    var emailContent = $"Your order #{order.Id} has been processed. Total: {order.Total:C}";
    emailService.SendEmail(order.CustomerEmail, "Order Confirmation", emailContent);
    
    // ログ記録
    logger.Log($"Order {order.Id} processed successfully for customer {order.CustomerEmail}");
}

// 改善例:メソッドの分割
public void ProcessOrder(Order order)
{
    ValidateOrder(order);
    CheckInventory(order);
    CalculateTotal(order);
    UpdateInventory(order);
    ProcessPayment(order);
    SendConfirmationEmail(order);
    LogOrderProcessing(order);
}

private void ValidateOrder(Order order)
{
    if (order == null) throw new ArgumentNullException(nameof(order));
    if (order.Items.Count == 0) throw new InvalidOperationException("Order must have items");
    if (string.IsNullOrEmpty(order.CustomerEmail)) throw new InvalidOperationException("Customer email is required");
}

private void CheckInventory(Order order)
{
    foreach (var item in order.Items)
    {
        var inventory = inventoryService.GetInventory(item.ProductId);
        if (inventory.Quantity < item.Quantity)
            throw new InvalidOperationException($"Insufficient inventory for {item.ProductName}");
    }
}

private void CalculateTotal(Order order)
{
    var subtotal = order.Items.Sum(item => item.Price * item.Quantity);
    var tax = subtotal * 0.08m;
    var shipping = subtotal > 5000 ? 0 : 500;
    order.Total = subtotal + tax + shipping;
}
```

#### 大きなクラス(Large Class)

```python
# 悪い例:責務が多すぎるクラス
class UserManager:
    def __init__(self):
        self.users = []
        self.database = Database()
        self.email_service = EmailService()
        self.logger = Logger()
    
    def create_user(self, name, email, password):
        # バリデーション
        if not self._validate_email(email):
            raise ValueError("Invalid email")
        if not self._validate_password(password):
            raise ValueError("Invalid password")
        
        # パスワードハッシュ化
        hashed_password = self._hash_password(password)
        
        # ユーザー作成
        user = User(name, email, hashed_password)
        self.users.append(user)
        
        # データベース保存
        self.database.save_user(user)
        
        # ウェルカムメール送信
        self.email_service.send_welcome_email(email, name)
        
        # ログ記録
        self.logger.log(f"User created: {email}")
        
        return user
    
    def authenticate_user(self, email, password):
        user = self.database.get_user_by_email(email)
        if user and self._verify_password(password, user.password_hash):
            self.logger.log(f"User authenticated: {email}")
            return user
        return None
    
    def _validate_email(self, email): # ... 実装
    def _validate_password(self, password): # ... 実装
    def _hash_password(self, password): # ... 実装
    def _verify_password(self, password, hash): # ... 実装

# 改善例:責務を分離
class User:
    def __init__(self, name, email, password_hash):
        self.name = name
        self.email = email
        self.password_hash = password_hash

class UserValidator:
    def validate_email(self, email):
        # メールバリデーションロジック
        return "@" in email and len(email) > 5
    
    def validate_password(self, password):
        # パスワードバリデーションロジック
        return len(password) >= 8

class PasswordService:
    def hash_password(self, password):
        # パスワードハッシュ化
        import hashlib
        return hashlib.sha256(password.encode()).hexdigest()
    
    def verify_password(self, password, hash):
        # パスワード検証
        return self.hash_password(password) == hash

class UserService:
    def __init__(self, user_repository, password_service, email_service, logger):
        self.user_repository = user_repository
        self.password_service = password_service
        self.email_service = email_service
        self.logger = logger
        self.validator = UserValidator()
    
    def create_user(self, name, email, password):
        if not self.validator.validate_email(email):
            raise ValueError("Invalid email")
        if not self.validator.validate_password(password):
            raise ValueError("Invalid password")
        
        password_hash = self.password_service.hash_password(password)
        user = User(name, email, password_hash)
        
        self.user_repository.save(user)
        self.email_service.send_welcome_email(email, name)
        self.logger.log(f"User created: {email}")
        
        return user
    
    def authenticate_user(self, email, password):
        user = self.user_repository.get_by_email(email)
        if user and self.password_service.verify_password(password, user.password_hash):
            self.logger.log(f"User authenticated: {email}")
            return user
        return None
```

#### 重複コード(Duplicated Code)

```javascript
// 悪い例:重複したバリデーションロジック
class UserForm {
    validateEmailOnSubmit(email) {
        if (!email) {
            this.showError('Email is required');
            return false;
        }
        if (!email.includes('@')) {
            this.showError('Invalid email format');
            return false;
        }
        if (email.length < 5) {
            this.showError('Email too short');
            return false;
        }
        return true;
    }
    
    validateEmailOnBlur(email) {
        if (!email) {
            this.showWarning('Email is required');
            return false;
        }
        if (!email.includes('@')) {
            this.showWarning('Invalid email format');
            return false;
        }
        if (email.length < 5) {
            this.showWarning('Email too short');
            return false;
        }
        return true;
    }
}

// 改善例:共通バリデーションの抽出
class EmailValidator {
    static validate(email) {
        const errors = [];
        
        if (!email) {
            errors.push('Email is required');
        } else {
            if (!email.includes('@')) {
                errors.push('Invalid email format');
            }
            if (email.length < 5) {
                errors.push('Email too short');
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }
}

class UserForm {
    validateEmailOnSubmit(email) {
        const result = EmailValidator.validate(email);
        if (!result.isValid) {
            result.errors.forEach(error => this.showError(error));
        }
        return result.isValid;
    }
    
    validateEmailOnBlur(email) {
        const result = EmailValidator.validate(email);
        if (!result.isValid) {
            result.errors.forEach(error => this.showWarning(error));
        }
        return result.isValid;
    }
}
```

#### データクラス(Data Class)

```java
// 悪い例:振る舞いのないデータクラス
public class Rectangle {
    public double width;
    public double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
}

// 使用側で計算ロジックが散在
public class GeometryCalculator {
    public double calculateArea(Rectangle rect) {
        return rect.width * rect.height;
    }
    
    public double calculatePerimeter(Rectangle rect) {
        return 2 * (rect.width + rect.height);
    }
    
    public boolean isSquare(Rectangle rect) {
        return rect.width == rect.height;
    }
}

// 改善例:振る舞いをクラスに移動
public class Rectangle {
    private final double width;
    private final double height;
    
    public Rectangle(double width, double height) {
        if (width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Width and height must be positive");
        }
        this.width = width;
        this.height = height;
    }
    
    public double getArea() {
        return width * height;
    }
    
    public double getPerimeter() {
        return 2 * (width + height);
    }
    
    public boolean isSquare() {
        return width == height;
    }
    
    public Rectangle scale(double factor) {
        return new Rectangle(width * factor, height * factor);
    }
    
    // 必要な場合のみゲッターを提供
    public double getWidth() { return width; }
    public double getHeight() { return height; }
    
    @Override
    public String toString() {
        return String.format("Rectangle(%.2f x %.2f)", width, height);
    }
}
```

#### 長いパラメータリスト(Long Parameter List)

```csharp
// 悪い例:長いパラメータリスト
public void CreateUser(
    string firstName, 
    string lastName, 
    string email, 
    string phone, 
    string address, 
    string city, 
    string zipCode, 
    string country,
    DateTime birthDate, 
    string gender, 
    bool isSubscribed, 
    string preferredLanguage)
{
    // 実装...
}

// 改善例1:パラメータオブジェクトの導入
public class UserCreationRequest
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Email { get; set; }
    public string Phone { get; set; }
    public Address Address { get; set; }
    public DateTime BirthDate { get; set; }
    public string Gender { get; set; }
    public bool IsSubscribed { get; set; }
    public string PreferredLanguage { get; set; }
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
    public string Country { get; set; }
}

public void CreateUser(UserCreationRequest request)
{
    // バリデーション
    ValidateUserRequest(request);
    
    // ユーザー作成ロジック
    var user = new User
    {
        FirstName = request.FirstName,
        LastName = request.LastName,
        Email = request.Email,
        Phone = request.Phone,
        Address = request.Address,
        BirthDate = request.BirthDate,
        Gender = request.Gender,
        IsSubscribed = request.IsSubscribed,
        PreferredLanguage = request.PreferredLanguage
    };
    
    userRepository.Save(user);
}

// 改善例2:Builderパターンの使用
public class UserBuilder
{
    private string firstName;
    private string lastName;
    private string email;
    private Address address;
    private DateTime birthDate;
    
    public UserBuilder SetName(string firstName, string lastName)
    {
        this.firstName = firstName;
        this.lastName = lastName;
        return this;
    }
    
    public UserBuilder SetEmail(string email)
    {
        this.email = email;
        return this;
    }
    
    public UserBuilder SetAddress(Address address)
    {
        this.address = address;
        return this;
    }
    
    public UserBuilder SetBirthDate(DateTime birthDate)
    {
        this.birthDate = birthDate;
        return this;
    }
    
    public User Build()
    {
        return new User
        {
            FirstName = firstName,
            LastName = lastName,
            Email = email,
            Address = address,
            BirthDate = birthDate
        };
    }
}

// 使用例
var user = new UserBuilder()
    .SetName("John", "Doe")
    .SetEmail("john@example.com")
    .SetAddress(new Address { City = "Tokyo", Country = "Japan" })
    .SetBirthDate(new DateTime(1990, 1, 1))
    .Build();
```

## 7.3 段階的改善のアプローチ

### 7.3.1 ストラングラーパターン(Strangler Pattern)

レガシーシステムを段階的に新しいシステムに置き換える手法。

```python
# 既存のレガシーコード
class LegacyOrderService:
    def calculate_total(self, items):
        total = 0
        for item in items:
            # 複雑な計算ロジック(変更が困難)
            if item['type'] == 'book':
                total += item['price'] * 0.95  # 5%割引
            elif item['type'] == 'electronics':
                total += item['price'] * 1.08  # 消費税
            else:
                total += item['price']
        return total

# ステップ1:新しいサービスを並行して導入
class ModernOrderService:
    def __init__(self):
        self.tax_calculator = TaxCalculator()
        self.discount_calculator = DiscountCalculator()
    
    def calculate_total(self, order):
        subtotal = sum(item.price * item.quantity for item in order.items)
        discount = self.discount_calculator.calculate_discount(order)
        tax = self.tax_calculator.calculate_tax(order)
        return subtotal - discount + tax

# ステップ2:ファサードパターンで段階的移行
class OrderServiceFacade:
    def __init__(self):
        self.legacy_service = LegacyOrderService()
        self.modern_service = ModernOrderService()
        self.feature_flag = FeatureFlag()
    
    def calculate_total(self, order):
        if self.feature_flag.is_enabled('use_modern_calculator'):
            return self.modern_service.calculate_total(order)
        else:
            # レガシー形式に変換
            legacy_items = self._convert_to_legacy_format(order)
            return self.legacy_service.calculate_total(legacy_items)
    
    def _convert_to_legacy_format(self, order):
        return [{'type': item.category, 'price': item.price} for item in order.items]

# ステップ3:完全移行後にレガシーコードを削除
class OrderService:
    def __init__(self):
        self.tax_calculator = TaxCalculator()
        self.discount_calculator = DiscountCalculator()
    
    def calculate_total(self, order):
        subtotal = sum(item.price * item.quantity for item in order.items)
        discount = self.discount_calculator.calculate_discount(order)
        tax = self.tax_calculator.calculate_tax(order)
        return subtotal - discount + tax
```

### 7.3.2 ブランチ・バイ・アブストラクション(Branch by Abstraction)

抽象化レイヤーを通して段階的に実装を切り替える手法。

```csharp
// ステップ1:既存の実装
public class OrderProcessor
{
    public void ProcessOrder(Order order)
    {
        // 直接データベースアクセス
        using var connection = new SqlConnection(connectionString);
        connection.Open();
        
        var command = new SqlCommand(
            "INSERT INTO Orders (CustomerId, Total) VALUES (@customerId, @total)", 
            connection);
        command.Parameters.AddWithValue("@customerId", order.CustomerId);
        command.Parameters.AddWithValue("@total", order.Total);
        command.ExecuteNonQuery();
    }
}

// ステップ2:抽象化レイヤーの導入
public interface IOrderRepository
{
    void SaveOrder(Order order);
}

public class SqlOrderRepository : IOrderRepository
{
    public void SaveOrder(Order order)
    {
        using var connection = new SqlConnection(connectionString);
        connection.Open();
        
        var command = new SqlCommand(
            "INSERT INTO Orders (CustomerId, Total) VALUES (@customerId, @total)", 
            connection);
        command.Parameters.AddWithValue("@customerId", order.CustomerId);
        command.Parameters.AddWithValue("@total", order.Total);
        command.ExecuteNonQuery();
    }
}

public class OrderProcessor
{
    private readonly IOrderRepository _orderRepository;
    
    public OrderProcessor(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }
    
    public void ProcessOrder(Order order)
    {
        _orderRepository.SaveOrder(order);
    }
}

// ステップ3:新しい実装の導入
public class NoSqlOrderRepository : IOrderRepository
{
    private readonly IMongoCollection<Order> _orders;
    
    public NoSqlOrderRepository(IMongoDatabase database)
    {
        _orders = database.GetCollection<Order>("orders");
    }
    
    public void SaveOrder(Order order)
    {
        _orders.InsertOne(order);
    }
}

// ステップ4:設定による切り替え
public class OrderRepositoryFactory
{
    public static IOrderRepository Create(string repositoryType)
    {
        return repositoryType.ToLower() switch
        {
            "sql" => new SqlOrderRepository(),
            "nosql" => new NoSqlOrderRepository(GetMongoDatabase()),
            _ => throw new ArgumentException($"Unknown repository type: {repositoryType}")
        };
    }
}
```

### 7.3.3 並行実行パターン(Parallel Run Pattern)

新旧システムを並行実行して結果を比較検証する手法。

```java
public class PaymentServiceMigrator {
    private final LegacyPaymentService legacyService;
    private final ModernPaymentService modernService;
    private final Logger logger;
    private final FeatureFlag featureFlag;
    
    public PaymentResult processPayment(PaymentRequest request) {
        PaymentResult legacyResult = legacyService.processPayment(request);
        
        if (featureFlag.isEnabled("enable_parallel_run")) {
            // 並行実行
            CompletableFuture<PaymentResult> modernResultFuture = 
                CompletableFuture.supplyAsync(() -> {
                    try {
                        return modernService.processPayment(request);
                    } catch (Exception e) {
                        logger.error("Modern service failed", e);
                        return PaymentResult.error("Modern service failed");
                    }
                });
            
            try {
                PaymentResult modernResult = modernResultFuture.get(5, TimeUnit.SECONDS);
                
                // 結果比較
                if (!resultsMatch(legacyResult, modernResult)) {
                    logger.warn("Results mismatch between legacy and modern service", 
                              Map.of("legacy", legacyResult, "modern", modernResult));
                }
                
                // 新サービスの成功率を記録
                recordServicePerformance(modernResult);
                
            } catch (TimeoutException e) {
                logger.warn("Modern service timeout");
            } catch (Exception e) {
                logger.error("Modern service error", e);
            }
        }
        
        // 現在はレガシーの結果を返す
        return legacyResult;
    }
    
    private boolean resultsMatch(PaymentResult legacy, PaymentResult modern) {
        return legacy.isSuccess() == modern.isSuccess() &&
               Objects.equals(legacy.getTransactionId(), modern.getTransactionId());
    }
    
    private void recordServicePerformance(PaymentResult result) {
        // メトリクス記録
        if (result.isSuccess()) {
            Metrics.counter("modern_payment_service.success").increment();
        } else {
            Metrics.counter("modern_payment_service.failure").increment();
        }
    }
}
```

## 7.4 レガシーコードの扱い方

### 7.4.1 レガシーコードの特徴

レガシーコードの典型的な特徴:
1. **テストがない**:動作は確認できるが、変更の影響が予測困難
2. **依存関係が複雑**:密結合により変更が困難
3. **文書化が不十分**:意図や設計思想が不明
4. **技術的負債の蓄積**:応急処置的な修正の積み重ね

### 7.4.2 レガシーコード改善の基本戦略

#### ステップ1:理解する

```python
# レガシーコードの例:意図が不明確
def process_data(data):
    result = []
    for item in data:
        if item[0] == 'A' and len(item) > 3:
            temp = item[1:].upper()
            if temp.find('X') == -1:
                result.append(temp + '_PROCESSED')
        elif item[0] == 'B':
            if len(item) > 5:
                result.append(item[2:] + '_SPECIAL')
    return result

# ステップ1:理解のためのテストを追加
def test_process_data_understanding():
    """既存の動作を理解するためのテスト"""
    # 既知の入力と出力をテストケースにする
    data = ['AXYZ', 'ABCDEF', 'BXYZUVW', 'CXYZ']
    result = process_data(data)
    
    # 実際の動作を記録
    assert result == ['XYZ_PROCESSED', 'ZUVW_SPECIAL']
    
    # エッジケースも確認
    assert process_data(['A']) == []
    assert process_data(['AXYX']) == []  # X が含まれる場合
    assert process_data(['B1']) == []    # 長さが不足
```

#### ステップ2:テストハーネスの構築

```csharp
// レガシークラスの例
public class LegacyOrderCalculator
{
    public decimal CalculateTotal(string customerId, List<Item> items, string discountCode)
    {
        // 複雑で理解困難なロジック
        decimal total = 0;
        
        // 顧客データベースから直接取得
        var customer = Database.GetCustomer(customerId);
        var discount = DiscountDatabase.GetDiscount(discountCode);
        
        foreach (var item in items)
        {
            var price = item.BasePrice;
            if (customer.Type == "Premium")
                price *= 0.9m;
            if (discount != null && discount.IsValid)
                price *= (1 - discount.Percentage);
            total += price;
        }
        
        if (customer.Country == "JP")
            total *= 1.08m; // 消費税
            
        return total;
    }
}

// ステップ2:テストハーネスの構築
[TestClass]
public class LegacyOrderCalculatorTests
{
    private LegacyOrderCalculator calculator;
    
    [TestInitialize]
    public void Setup()
    {
        calculator = new LegacyOrderCalculator();
        // テストデータベースのセットアップ
        SetupTestDatabase();
    }
    
    [TestMethod]
    public void CalculateTotal_PremiumCustomerWithDiscount_ReturnsCorrectTotal()
    {
        // Arrange
        var customerId = "PREMIUM_123";
        var items = new List<Item> 
        { 
            new Item { BasePrice = 1000m },
            new Item { BasePrice = 2000m }
        };
        var discountCode = "DISCOUNT_10";
        
        // Act
        var total = calculator.CalculateTotal(customerId, items, discountCode);
        
        // Assert
        // プレミアム割引(10%) + 追加割引(10%) + 消費税(8%)
        var expected = (3000m * 0.9m * 0.9m) * 1.08m;
        Assert.AreEqual(expected, total, 0.01m);
    }
    
    private void SetupTestDatabase()
    {
        // テスト用データの設定
        Database.SetTestData("PREMIUM_123", new Customer 
        { 
            Type = "Premium", 
            Country = "JP" 
        });
        DiscountDatabase.SetTestData("DISCOUNT_10", new Discount 
        { 
            Percentage = 0.1m, 
            IsValid = true 
        });
    }
}
```

#### ステップ3:段階的な抽出と改善

```csharp
// ステップ3:段階的に責務を抽出
public interface ICustomerService
{
    Customer GetCustomer(string customerId);
}

public interface IDiscountService
{
    Discount GetDiscount(string discountCode);
}

public interface ITaxService
{
    decimal CalculateTax(decimal amount, string country);
}

// 改善されたバージョン
public class OrderCalculator
{
    private readonly ICustomerService customerService;
    private readonly IDiscountService discountService;
    private readonly ITaxService taxService;
    
    public OrderCalculator(
        ICustomerService customerService,
        IDiscountService discountService,
        ITaxService taxService)
    {
        this.customerService = customerService;
        this.discountService = discountService;
        this.taxService = taxService;
    }
    
    public decimal CalculateTotal(string customerId, List<Item> items, string discountCode)
    {
        var customer = customerService.GetCustomer(customerId);
        var discount = discountService.GetDiscount(discountCode);
        
        var subtotal = CalculateSubtotal(items, customer, discount);
        var total = taxService.CalculateTax(subtotal, customer.Country);
        
        return total;
    }
    
    private decimal CalculateSubtotal(List<Item> items, Customer customer, Discount discount)
    {
        decimal subtotal = 0;
        
        foreach (var item in items)
        {
            var price = ApplyCustomerDiscount(item.BasePrice, customer);
            price = ApplyPromotionalDiscount(price, discount);
            subtotal += price;
        }
        
        return subtotal;
    }
    
    private decimal ApplyCustomerDiscount(decimal price, Customer customer)
    {
        return customer.Type == "Premium" ? price * 0.9m : price;
    }
    
    private decimal ApplyPromotionalDiscount(decimal price, Discount discount)
    {
        return discount?.IsValid == true ? price * (1 - discount.Percentage) : price;
    }
}

// レガシーとの互換性を保つアダプター
public class LegacyOrderCalculatorAdapter
{
    private readonly OrderCalculator modernCalculator;
    
    public LegacyOrderCalculatorAdapter()
    {
        modernCalculator = new OrderCalculator(
            new DatabaseCustomerService(),
            new DatabaseDiscountService(),
            new TaxService()
        );
    }
    
    public decimal CalculateTotal(string customerId, List<Item> items, string discountCode)
    {
        return modernCalculator.CalculateTotal(customerId, items, discountCode);
    }
}
```

### 7.4.3 セーフティネットパターン

レガシーシステムの改修において、既存機能を壊さないための安全策。

```java
public class SafeRefactoringService {
    private final LegacyService legacyService;
    private final ModernService modernService;
    private final CircuitBreaker circuitBreaker;
    private final Logger logger;
    
    public Result processRequest(Request request) {
        try {
            // 新しいサービスを試行
            if (circuitBreaker.isAvailable()) {
                Result modernResult = modernService.process(request);
                
                // 成功した場合は結果を返す
                if (modernResult.isSuccess()) {
                    circuitBreaker.recordSuccess();
                    return modernResult;
                }
                
                // 失敗した場合はフォールバック
                logger.warn("Modern service failed, falling back to legacy", 
                          modernResult.getError());
                circuitBreaker.recordFailure();
            }
            
        } catch (Exception e) {
            logger.error("Modern service threw exception, falling back to legacy", e);
            circuitBreaker.recordFailure();
        }
        
        // レガシーサービスにフォールバック
        return legacyService.process(request);
    }
}

// サーキットブレーカーの実装例
public class CircuitBreaker {
    private final int failureThreshold;
    private final long timeoutMillis;
    private int failureCount = 0;
    private long lastFailureTime = 0;
    private State state = State.CLOSED;
    
    public enum State { CLOSED, OPEN, HALF_OPEN }
    
    public boolean isAvailable() {
        if (state == State.CLOSED) {
            return true;
        }
        
        if (state == State.OPEN) {
            if (System.currentTimeMillis() - lastFailureTime > timeoutMillis) {
                state = State.HALF_OPEN;
                return true;
            }
            return false;
        }
        
        // HALF_OPEN state
        return true;
    }
    
    public void recordSuccess() {
        failureCount = 0;
        state = State.CLOSED;
    }
    
    public void recordFailure() {
        failureCount++;
        lastFailureTime = System.currentTimeMillis();
        
        if (failureCount >= failureThreshold) {
            state = State.OPEN;
        }
    }
}
```

## 7.5 実践演習:リファクタリング技法

### 7.5.1 演習課題:ECサイトの注文処理システム

以下のレガシーコードをリファクタリングして改善しよう。

```python
# 演習対象:レガシーな注文処理システム
class OrderProcessor:
    def __init__(self):
        self.db = Database()
        self.email = EmailService()
        self.sms = SMSService()
        self.payment = PaymentService()
        
    def process_order(self, order_data):
        # バリデーション
        if not order_data:
            return {"status": "error", "message": "No order data"}
        if "customer_id" not in order_data:
            return {"status": "error", "message": "Customer ID required"}
        if "items" not in order_data or len(order_data["items"]) == 0:
            return {"status": "error", "message": "Items required"}
        
        customer = self.db.get_customer(order_data["customer_id"])
        if not customer:
            return {"status": "error", "message": "Customer not found"}
            
        # 在庫チェック
        for item in order_data["items"]:
            stock = self.db.get_stock(item["product_id"])
            if stock < item["quantity"]:
                return {"status": "error", "message": f"Insufficient stock for {item['product_id']}"}
        
        # 価格計算
        total = 0
        for item in order_data["items"]:
            product = self.db.get_product(item["product_id"])
            price = product["price"] * item["quantity"]
            
            # 顧客タイプ別割引
            if customer["type"] == "premium":
                price = price * 0.9
            elif customer["type"] == "gold":
                price = price * 0.85
            
            # カテゴリ別税率
            if product["category"] == "food":
                price = price * 1.05  # 軽減税率
            else:
                price = price * 1.08  # 標準税率
                
            total += price
        
        # 送料計算
        if total < 5000:
            shipping = 500
        else:
            shipping = 0
            
        total += shipping
        
        # 支払い処理
        payment_result = self.payment.charge(customer["payment_method"], total)
        if not payment_result["success"]:
            return {"status": "error", "message": "Payment failed"}
            
        # 在庫更新
        for item in order_data["items"]:
            self.db.update_stock(item["product_id"], -item["quantity"])
            
        # 注文保存
        order_id = self.db.save_order({
            "customer_id": order_data["customer_id"],
            "items": order_data["items"],
            "total": total,
            "payment_id": payment_result["payment_id"]
        })
        
        # 通知送信
        if customer["notification_preference"] == "email":
            self.email.send(customer["email"], "Order Confirmation", 
                          f"Your order #{order_id} has been confirmed. Total: ${total}")
        elif customer["notification_preference"] == "sms":
            self.sms.send(customer["phone"], f"Order #{order_id} confirmed. Total: ${total}")
            
        return {"status": "success", "order_id": order_id, "total": total}
```

### 7.5.2 演習解答例:段階的リファクタリング

#### ステップ1:テストハーネスの構築

```python
import unittest
from unittest.mock import Mock, patch

class TestOrderProcessor(unittest.TestCase):
    def setUp(self):
        self.processor = OrderProcessor()
        
        # モックの設定
        self.processor.db = Mock()
        self.processor.email = Mock()
        self.processor.sms = Mock()
        self.processor.payment = Mock()
        
    def test_process_order_success_premium_customer(self):
        # テストデータ準備
        order_data = {
            "customer_id": "CUST001",
            "items": [
                {"product_id": "PROD001", "quantity": 2}
            ]
        }
        
        # モックの戻り値設定
        self.processor.db.get_customer.return_value = {
            "type": "premium",
            "email": "test@example.com",
            "notification_preference": "email",
            "payment_method": "credit_card"
        }
        self.processor.db.get_stock.return_value = 10
        self.processor.db.get_product.return_value = {
            "price": 1000,
            "category": "electronics"
        }
        self.processor.payment.charge.return_value = {
            "success": True,
            "payment_id": "PAY001"
        }
        self.processor.db.save_order.return_value = "ORDER001"
        
        # テスト実行
        result = self.processor.process_order(order_data)
        
        # 検証
        self.assertEqual(result["status"], "success")
        self.assertEqual(result["order_id"], "ORDER001")
        # プレミアム割引(10%) + 消費税(8%) = 1944円
        expected_total = 1000 * 2 * 0.9 * 1.08 + 500  # 送料込み
        self.assertEqual(result["total"], expected_total)
```

#### ステップ2:責務の分離

```python
# バリデーション責務の分離
class OrderValidator:
    def validate(self, order_data):
        errors = []
        
        if not order_data:
            errors.append("No order data")
            
        if not order_data.get("customer_id"):
            errors.append("Customer ID required")
            
        items = order_data.get("items", [])
        if not items:
            errors.append("Items required")
            
        return errors

# 価格計算責務の分離
class PriceCalculator:
    def __init__(self, discount_service, tax_service):
        self.discount_service = discount_service
        self.tax_service = tax_service
    
    def calculate_item_total(self, product, quantity, customer):
        base_price = product["price"] * quantity
        discounted_price = self.discount_service.apply_discount(base_price, customer)
        final_price = self.tax_service.apply_tax(discounted_price, product)
        return final_price
    
    def calculate_shipping(self, subtotal):
        return 0 if subtotal >= 5000 else 500

# 割引サービス
class DiscountService:
    DISCOUNT_RATES = {
        "premium": 0.9,
        "gold": 0.85,
        "regular": 1.0
    }
    
    def apply_discount(self, price, customer):
        rate = self.DISCOUNT_RATES.get(customer.get("type", "regular"), 1.0)
        return price * rate

# 税金サービス
class TaxService:
    TAX_RATES = {
        "food": 1.05,    # 軽減税率
        "default": 1.08  # 標準税率
    }
    
    def apply_tax(self, price, product):
        rate = self.TAX_RATES.get(product.get("category"), self.TAX_RATES["default"])
        return price * rate

# 在庫サービス
class InventoryService:
    def __init__(self, db):
        self.db = db
    
    def check_availability(self, items):
        unavailable_items = []
        
        for item in items:
            stock = self.db.get_stock(item["product_id"])
            if stock < item["quantity"]:
                unavailable_items.append(item["product_id"])
                
        return unavailable_items
    
    def reserve_items(self, items):
        for item in items:
            self.db.update_stock(item["product_id"], -item["quantity"])

# 通知サービス
class NotificationService:
    def __init__(self, email_service, sms_service):
        self.email_service = email_service
        self.sms_service = sms_service
    
    def send_order_confirmation(self, customer, order_id, total):
        message = f"Order #{order_id} confirmed. Total: ${total}"
        
        if customer["notification_preference"] == "email":
            self.email_service.send(customer["email"], "Order Confirmation", message)
        elif customer["notification_preference"] == "sms":
            self.sms_service.send(customer["phone"], message)
```

#### ステップ3:改善されたOrderProcessor

```python
class OrderProcessor:
    def __init__(self, db, payment_service, email_service, sms_service):
        self.db = db
        self.payment_service = payment_service
        
        # 各サービスの初期化
        self.validator = OrderValidator()
        self.discount_service = DiscountService()
        self.tax_service = TaxService()
        self.price_calculator = PriceCalculator(self.discount_service, self.tax_service)
        self.inventory_service = InventoryService(db)
        self.notification_service = NotificationService(email_service, sms_service)
    
    def process_order(self, order_data):
        try:
            # バリデーション
            validation_errors = self.validator.validate(order_data)
            if validation_errors:
                return self._error_response("; ".join(validation_errors))
            
            # 顧客情報取得
            customer = self.db.get_customer(order_data["customer_id"])
            if not customer:
                return self._error_response("Customer not found")
            
            # 在庫チェック
            unavailable_items = self.inventory_service.check_availability(order_data["items"])
            if unavailable_items:
                return self._error_response(f"Insufficient stock for: {', '.join(unavailable_items)}")
            
            # 合計金額計算
            total = self._calculate_total(order_data["items"], customer)
            
            # 支払い処理
            payment_result = self.payment_service.charge(customer["payment_method"], total)
            if not payment_result["success"]:
                return self._error_response("Payment failed")
            
            # 在庫更新
            self.inventory_service.reserve_items(order_data["items"])
            
            # 注文保存
            order_id = self._save_order(order_data, total, payment_result["payment_id"])
            
            # 通知送信
            self.notification_service.send_order_confirmation(customer, order_id, total)
            
            return {
                "status": "success",
                "order_id": order_id,
                "total": total
            }
            
        except Exception as e:
            return self._error_response(f"Unexpected error: {str(e)}")
    
    def _calculate_total(self, items, customer):
        subtotal = 0
        
        for item in items:
            product = self.db.get_product(item["product_id"])
            item_total = self.price_calculator.calculate_item_total(
                product, item["quantity"], customer)
            subtotal += item_total
        
        shipping = self.price_calculator.calculate_shipping(subtotal)
        return subtotal + shipping
    
    def _save_order(self, order_data, total, payment_id):
        return self.db.save_order({
            "customer_id": order_data["customer_id"],
            "items": order_data["items"],
            "total": total,
            "payment_id": payment_id
        })
    
    def _error_response(self, message):
        return {"status": "error", "message": message}
```

#### ステップ4:更なる改善(ドメインモデルの導入)

```python
from dataclasses import dataclass
from typing import List
from enum import Enum

class CustomerType(Enum):
    REGULAR = "regular"
    PREMIUM = "premium"
    GOLD = "gold"

class NotificationPreference(Enum):
    EMAIL = "email"
    SMS = "sms"

@dataclass
class Customer:
    id: str
    type: CustomerType
    email: str
    phone: str
    notification_preference: NotificationPreference
    payment_method: str

@dataclass
class Product:
    id: str
    name: str
    price: float
    category: str

@dataclass
class OrderItem:
    product_id: str
    quantity: int

@dataclass
class Order:
    customer_id: str
    items: List[OrderItem]
    total: float = 0
    order_id: str = None

# ドメインサービス
class OrderDomainService:
    def __init__(self, 
                 customer_repository,
                 product_repository,
                 inventory_service,
                 price_calculator,
                 payment_service,
                 notification_service):
        self.customer_repository = customer_repository
        self.product_repository = product_repository
        self.inventory_service = inventory_service
        self.price_calculator = price_calculator
        self.payment_service = payment_service
        self.notification_service = notification_service
    
    def process_order(self, order: Order) -> OrderResult:
        # 顧客取得
        customer = self.customer_repository.get_by_id(order.customer_id)
        if not customer:
            return OrderResult.failure("Customer not found")
        
        # 商品情報取得
        products = self._get_products(order.items)
        
        # 在庫チェック
        if not self.inventory_service.check_availability(order.items):
            return OrderResult.failure("Insufficient inventory")
        
        # 価格計算
        order.total = self.price_calculator.calculate_total(products, order.items, customer)
        
        # 支払い処理
        payment_result = self.payment_service.process_payment(customer, order.total)
        if not payment_result.is_success:
            return OrderResult.failure("Payment failed")
        
        # 在庫確保
        self.inventory_service.reserve_items(order.items)
        
        # 注文保存
        order.order_id = self._save_order(order, payment_result.payment_id)
        
        # 通知送信
        self.notification_service.send_confirmation(customer, order)
        
        return OrderResult.success(order)
    
    def _get_products(self, items: List[OrderItem]) -> List[Product]:
        return [self.product_repository.get_by_id(item.product_id) for item in items]
    
    def _save_order(self, order: Order, payment_id: str) -> str:
        # 注文保存の実装
        pass

@dataclass
class OrderResult:
    is_success: bool
    order: Order = None
    error_message: str = None
    
    @classmethod
    def success(cls, order: Order):
        return cls(is_success=True, order=order)
    
    @classmethod
    def failure(cls, error_message: str):
        return cls(is_success=False, error_message=error_message)
```

### 7.5.3 演習のポイント

#### リファクタリングの段階的アプローチ
1. **理解**: 既存コードの動作をテストで確認
2. **抽出**: 責務ごとにクラス・メソッドを分離
3. **改善**: より良い設計パターンの適用
4. **検証**: リファクタリング後もテストが通ることを確認

#### 得られた改善点
- **単一責務**: 各クラスが明確な責務を持つ
- **テスタビリティ**: 依存関係が注入され、個別テストが可能
- **拡張性**: 新しい割引ルールや税率を容易に追加可能
- **理解容易性**: コードの意図が明確に表現されている

---

**章末まとめ**

第7章では、リファクタリングの基本原則から始まり、コードの臭いの識別と対処、段階的改善のアプローチ、そしてレガシーコードの扱い方について学んだ。

リファクタリングは美しいソースコードを維持するための継続的なプロセスである。適切なテストスイートを基盤として、小さな段階的変更を積み重ねることで、コードの品質を向上させることができる。

特に重要なのは、リファクタリングが「外部的振る舞いを変えることなく内部構造を改善する」ことであり、この原則を守ることで安全に品質改善を進めることができる点である。

次章では、より実践的なコーディング手法について詳しく学んでいく。