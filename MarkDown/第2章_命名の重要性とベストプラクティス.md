# 第2章　命名の重要性とベストプラクティス

## 2.1　命名はモデリングの核心

### 2.1.1　命名とモデリングの関係

「**名前重要。**」

プログラミングにおいて命名は根本的に重要である。Ruby の作者のまつもとゆきひろ氏 (Matz) も「プログラマが知るべき97のこと」という書籍の中で「名前重要」という言葉を使っている。

命名は単なる識別子の選択ではない。それは**モデリングの中心的な行為**である。プログラミングにおけるモデリングとは、現実世界の複雑さから必要な要素を抽出し、コンピュータで扱える形に抽象化することである。

### 2.1.2　「ソースコードを書く」という行為はモデリング

「ソースコードを書く」という行為を次のように定義したい：

> 「ソースコードを書く」という行為は**設計＋実装＋テスト**である

これは単純なコーディング作業ではなく、**検証可能な設計/実装モデル**を作成する知的活動である。このモデルは以下の特徴を持つ：

1. **人間が理解できる**：開発者が意図を把握できる
2. **機械が実行できる**：コンピュータが処理できる
3. **検証可能である**：テストによって正しさを確認できる

### 2.1.3　モデルとしてのソースコード

ソフトウェア開発には複数のモデルが存在する：

#### 分析モデル（Analysis Model）
- **目的**：顧客の問題領域を理解する
- **視点**：ビジネス要求、ユーザーのニーズ
- **表現**：要求仕様書、ユースケース図

#### 設計モデル（Design Model）
- **目的**：ITの世界での解決策を設計する
- **視点**：アーキテクチャ、コンポーネント設計
- **表現**：クラス図、シーケンス図

#### 実装モデル（Implementation Model）
- **目的**：具体的な動作するシステムを構築する
- **視点**：プログラミング言語による実装
- **表現**：ソースコード

これらのモデル間で**一貫性**を保つことが重要であり、命名はその一貫性を保つ最も重要な手段である。

```csharp
// 分析モデルの概念をそのまま実装モデルに反映
public class Customer  // 顧客という分析モデルの概念
{
    public void PlaceOrder(Product product)  // 注文するという業務行為
    {
        var order = new Order(this, product);  // 注文という業務概念
        order.Submit();  // 提出するという業務プロセス
    }
}
```

### 2.1.4　関心の分離（Separation of Concerns）

モデリングの基本原理は**関心の分離**である。複雑なシステムから特定の関心事を切り出し、それぞれを独立して扱うことで複雑さを管理する。

```csharp
// 悪い例：複数の関心事が混在
public class OrderProcessor
{
    public void ProcessOrder(string orderData)
    {
        // データ解析の関心事
        var parts = orderData.Split(',');
        
        // ビジネスルールの関心事
        if (decimal.Parse(parts[2]) > 1000) 
        {
            // データ永続化の関心事
            SaveToDatabase(parts);
            
            // 通知の関心事
            SendEmail(parts[0]);
        }
    }
}
```

```csharp
// 良い例：関心事を分離
public class OrderProcessor
{
    private readonly IOrderParser _parser;
    private readonly IOrderValidator _validator;
    private readonly IOrderRepository _repository;
    private readonly INotificationService _notificationService;
    
    public void ProcessOrder(string orderData)
    {
        var order = _parser.Parse(orderData);      // データ解析
        _validator.Validate(order);               // ビジネスルール
        _repository.Save(order);                  // データ永続化
        _notificationService.NotifyCustomer(order); // 通知
    }
}
```

## 2.2　Name and Conquer：定義攻略の技法

### 2.2.1　Name and Conquerの概念

ソフトウェア開発の複雑さに対処するための基本戦略は2つある：

1. **Divide and Conquer（分割攻略）**：大きな問題を小さな問題に分割する
2. **Name and Conquer（定義攻略）**：注目すべきものを見つけて名前を付ける

Name and Conquerは以下のプロセスで実行される：

### 2.2.2　概念の確定と境界設定

名前を付けるということは、システム全体という「混沌」の中から特定の概念を切り出し、その概念の範囲を確定させる行為である。

```csharp
// 混沌とした状態：責務が不明確
public class SystemManager
{
    public void DoWork(object input)
    {
        // 何をするクラスなのか不明
        // 何を受け取るメソッドなのか不明
    }
}
```

```csharp
// 概念を確定：責務が明確
public class CustomerOrderValidator  // 「顧客注文検証」という概念を確定
{
    public ValidationResult Validate(CustomerOrder order)  // 境界を明確に設定
    {
        // この範囲の概念を「CustomerOrderValidator」と呼ぶことを定義
        // 「顧客注文検証」に関することと「それ以外」の境界が明確
    }
}
```

### 2.2.3　名前による責務の限定

適切な名前は、そのコンポーネントが**何をすべきか**と同時に**何をすべきでないか**を明確にする。

```csharp
// 名前による責務の限定の例
public class PriceCalculator  // 価格計算に責務を限定
{
    public decimal CalculateTotal(List<OrderItem> items)
    {
        // 価格計算に関することのみを実装
        // データ保存や通知は責務外
        return items.Sum(item => item.Price * item.Quantity);
    }
    
    // 以下のようなメソッドは責務外なので含めない
    // void SaveOrder(Order order)  ← データ保存は別の責務
    // void SendEmail(string email)  ← 通知も別の責務
}
```

### 2.2.4　概念階層の構築

Name and Conquerを適用することで、概念の階層構造を構築できる：

```csharp
// 概念階層の例
namespace OrderManagement  // 注文管理という大きな概念
{
    // 注文処理という中レベルの概念
    public class OrderProcessor
    {
        private readonly OrderValidator _validator;     // 注文検証という小さな概念
        private readonly PriceCalculator _calculator;   // 価格計算という小さな概念
        private readonly InventoryChecker _inventory;   // 在庫確認という小さな概念
    }
    
    // 各概念がさらに細かい概念に分解される
    public class OrderValidator
    {
        private readonly CustomerValidator _customerValidator;  // 顧客検証
        private readonly ProductValidator _productValidator;    // 商品検証
        private readonly PaymentValidator _paymentValidator;    // 支払い検証
    }
}
```

## 2.3　サービス指向名前付け（SON）

### 2.3.1　SONの基本思想

Service Oriented Naming（SON）は、**クライアント（利用者）の視点**で名前を決定するアプローチである。重要なのは「提供者がどう実装するか」ではなく、「利用者がどう使いたいか」である。

### 2.3.2　ユーザーインターフェースとしての名前

プログラムの名前は、そのコンポーネントの**ユーザーインターフェース**である：

```csharp
// 実装者視点の命名（悪い例）
public class SqlCustomerDataAccessObject
{
    public DataTable ExecuteSqlQuery(string sql) { }
    public int ExecuteSqlNonQuery(string sql) { }
}

// クライアント視点の命名（良い例）
public class CustomerRepository
{
    public Customer FindById(int customerId) { }
    public List<Customer> FindByName(string name) { }
    public void Save(Customer customer) { }
    public void Delete(int customerId) { }
}
```

クライアントコードを比較すると違いは明確である：

```csharp
// 実装者視点の名前を使ったクライアントコード
var dao = new SqlCustomerDataAccessObject();
var table = dao.ExecuteSqlQuery("SELECT * FROM Customers WHERE Id = " + customerId);
// クライアントがSQLを書く必要がある
// データベースの実装詳細が露出している

// ユーザー視点の名前を使ったクライアントコード
var repository = new CustomerRepository();
var customer = repository.FindById(customerId);
// クライアントはビジネス概念で操作できる
// 実装詳細は隠蔽されている
```

### 2.3.3　サービスとしてのメソッド

各メソッドは、クライアントに対する**サービス**として設計すべきである：

```csharp
public class EmailService  // クライアントにメール機能を提供
{
    // クライアントが欲しいサービス：「お客様に通知する」
    public void NotifyCustomer(Customer customer, string message)
    {
        // 実装詳細（SMTPサーバー、メールテンプレートなど）は隠蔽
    }
    
    // クライアントが欲しいサービス：「管理者に警告する」
    public void AlertAdministrator(string alertMessage)
    {
        // 実装詳細は隠蔽
    }
}
```

### 2.3.4　ドメイン固有の語彙

サービス指向の命名では、そのドメイン（問題領域）で使われる自然な語彙を採用する：

```csharp
// 銀行システムの例：銀行業界の語彙を使用
public class Account  // 口座
{
    public void Deposit(decimal amount)    // 預金
    public void Withdraw(decimal amount)   // 引き出し
    public decimal GetBalance()            // 残高照会
    public void Transfer(Account to, decimal amount)  // 振込
}

// ECサイトの例：小売業界の語彙を使用
public class ShoppingCart  // ショッピングカート
{
    public void AddItem(Product product)     // 商品をカートに追加
    public void RemoveItem(Product product)  // 商品をカートから削除
    public void Checkout()                   // レジに進む
    public decimal GetTotal()                // 合計金額
}
```

## 2.4　命名のアンチパターンと対策

### 2.4.1　数字を付ける

#### アンチパターン
```csharp
public class CustomerService1
{
    public void ProcessCustomer1(Customer customer) { }
}

public class CustomerService2  
{
    public void ProcessCustomer2(Customer customer) { }
}
```

#### 問題点
- 違いが分からない
- 責務の境界が不明確
- どちらを使うべきか判断できない

#### 対策
```csharp
public class CustomerRegistrationService
{
    public void RegisterNewCustomer(Customer customer) { }
}

public class CustomerNotificationService
{
    public void NotifyCustomerStatusChange(Customer customer) { }
}
```

### 2.4.2　省略する

#### アンチパターン
```csharp
public class CustMgr
{
    public void ProcOrd(Ord ord) { }
    private List<Cust> custs;
    private Dict<string, Prod> prods;
}
```

#### 問題点
- 読みにくい
- 意味の推測が必要
- チーム内で解釈が分かれる

#### 対策
```csharp
public class CustomerManager
{
    public void ProcessOrder(Order order) { }
    private List<Customer> customers;
    private Dictionary<string, Product> products;
}
```

### 2.4.3　意味不明な名前

#### アンチパターン
```csharp
public class Thing
{
    public object Data { get; set; }
    public void DoStuff(object input) { }
    public List<object> Items { get; set; }
}
```

#### 問題点
- 何をするクラスか分からない
- 責務が特定できない
- 保守が困難

#### 対策
```csharp
public class OrderValidationResult
{
    public List<ValidationError> Errors { get; set; }
    public bool IsValid => !Errors.Any();
    public void AddError(ValidationError error) { }
}
```

### 2.4.4　型名を含める

#### アンチパターン
```csharp
public class CustomerList : List<Customer> { }
public class OrderDictionary : Dictionary<int, Order> { }
public class ProductInterface { }
public class OrderClass { }
```

#### 問題点
- 実装の詳細が名前に漏れている
- 実装変更時に名前も変更が必要
- 抽象化レベルが適切でない

#### 対策
```csharp
public class Customers : IEnumerable<Customer>  // 概念を表現
{
    private readonly List<Customer> _customers = new();
    
    public void Add(Customer customer) => _customers.Add(customer);
    public Customer FindByEmail(string email) => 
        _customers.FirstOrDefault(c => c.Email == email);
}

public interface IOrderLookup  // 振る舞いを表現
{
    Order FindById(int orderId);
}
```

### 2.4.5　統一感がない

#### アンチパターン
```csharp
public class CustomerService
{
    public Customer GetCustomer(int id) { }      // Get prefix
    public Order RetrieveOrder(int id) { }      // Retrieve prefix  
    public Product FetchProduct(int id) { }     // Fetch prefix
    public void SaveCustomer(Customer c) { }    // Save verb
    public void StoreOrder(Order o) { }         // Store verb
    public void PersistProduct(Product p) { }   // Persist verb
}
```

#### 問題点
- 学習コストが高い
- 予測できない
- チーム内で混乱が生じる

#### 対策
```csharp
public class CustomerService
{
    // 統一されたFind/Saveパターン
    public Customer FindById(int customerId) { }
    public Order FindOrderById(int orderId) { }
    public Product FindProductById(int productId) { }
    
    public void Save(Customer customer) { }
    public void Save(Order order) { }
    public void Save(Product product) { }
}
```

## 2.5　実践演習：効果的な命名技法

### 2.5.1　命名の段階的改善

#### Step 1: 現状分析

以下のコードの命名上の問題点を特定せよ：

```csharp
public class DataProcessor
{
    private List<object> list1;
    private Dictionary<string, object> dict1;
    
    public void Process(object input)
    {
        // データ処理
        var result = DoWork(input);
        Save(result);
        Send(result);
    }
    
    private object DoWork(object data)
    {
        // 複雑な処理
        return null;
    }
    
    private void Save(object obj) { }
    private void Send(object obj) { }
}
```

#### Step 2: 問題点の特定

1. **意味不明な名前**: `DataProcessor`, `DoWork`
2. **一般的すぎる名前**: `Process`, `Save`, `Send`
3. **型情報の不足**: すべて`object`型
4. **番号付け**: `list1`, `dict1`
5. **責務が不明確**: 何のデータを処理するのか不明

#### Step 3: 段階的改善

**段階1: 意味のある名前に変更**
```csharp
public class OrderProcessor  // より具体的な名前
{
    private List<Order> pendingOrders;        // 具体的な型と意味
    private Dictionary<string, Product> productCatalog;  // 意味のある名前
    
    public void ProcessOrder(Order order)    // 具体的な引数型
    {
        var validatedOrder = ValidateOrder(order);  // 明確な処理内容
        SaveOrder(validatedOrder);
        SendConfirmation(validatedOrder);
    }
    
    private Order ValidateOrder(Order order)  // 処理内容が明確
    {
        // 注文検証処理
        return order;
    }
    
    private void SaveOrder(Order order) { }
    private void SendConfirmation(Order order) { }
}
```

**段階2: 責務をさらに分離**
```csharp
public class OrderProcessingWorkflow  // ワークフロー全体を管理
{
    private readonly IOrderValidator _validator;
    private readonly IOrderRepository _repository;
    private readonly ICustomerNotificationService _notificationService;
    
    public async Task<OrderProcessingResult> ProcessNewOrder(Order order)
    {
        var validationResult = await _validator.ValidateAsync(order);
        if (!validationResult.IsValid)
            return OrderProcessingResult.ValidationFailed(validationResult.Errors);
            
        await _repository.SaveAsync(order);
        await _notificationService.SendOrderConfirmationAsync(order);
        
        return OrderProcessingResult.Success(order);
    }
}
```

### 2.5.2　ドメイン概念の抽出

#### 演習: ECサイトの概念モデリング

以下の要求から適切なクラス名とメソッド名を抽出せよ：

**要求**: 
「顧客は商品をショッピングカートに追加し、決済を行い、注文を確定する。注文が確定すると在庫から商品が引き当てられ、出荷準備が開始される。」

#### 解答例:

```csharp
// ドメイン概念を自然な名前で表現
public class Customer
{
    public ShoppingCart CreateShoppingCart() { }
    public Order PlaceOrder(ShoppingCart cart, PaymentMethod payment) { }
}

public class ShoppingCart
{
    public void AddProduct(Product product, int quantity) { }
    public void RemoveProduct(Product product) { }
    public void UpdateQuantity(Product product, int newQuantity) { }
    public CheckoutSession StartCheckout() { }
}

public class CheckoutSession
{
    public PaymentResult ProcessPayment(PaymentMethod method) { }
    public Order ConfirmOrder() { }
}

public class Order
{
    public OrderStatus Status { get; private set; }
    public void Confirm() { }
    public void Cancel() { }
}

public class InventoryService
{
    public ReservationResult ReserveProducts(Order order) { }
    public void ReleaseReservation(Order order) { }
}

public class ShippingService
{
    public void PrepareShipment(Order order) { }
    public TrackingNumber CreateShipment(Order order) { }
}
```

### 2.5.3　メタファ（隠喩）の活用

#### 概念

抽象的すぎて伝わりにくい概念は、**身近なメタファ**で表現することで理解しやすくなる。

#### 例1: デザインパターンのメタファ

```csharp
// Factory（工場）のメタファ
public class CustomerFactory
{
    public Customer CreatePremiumCustomer(string name, string email) { }
    public Customer CreateRegularCustomer(string name, string email) { }
}

// Observer（観察者）のメタファ
public interface IOrderStatusObserver
{
    void OnOrderStatusChanged(Order order, OrderStatus newStatus);
}

// Strategy（戦略）のメタファ
public interface IDiscountStrategy
{
    decimal ApplyDiscount(decimal originalPrice);
}
```

#### 例2: ビジネス概念のメタファ

```csharp
// Pipeline（パイプライン）のメタファ
public class DataProcessingPipeline
{
    public void AddStage(IProcessingStage stage) { }
    public ProcessingResult Execute(InputData data) { }
}

// Cache（キャッシュ）のメタファ
public class ProductCatalogCache
{
    public Product Get(int productId) { }
    public void Invalidate(int productId) { }
    public void Refresh() { }
}
```

### 2.5.4　命名の一貫性チェックリスト

以下のチェックリストを使用して命名の品質を評価せよ：

#### 意図の表現
- [ ] 名前を見ただけで何をするか分かるか？
- [ ] Why（なぜ）、What（何を）が表現されているか？
- [ ] How（どうやって）の詳細は隠蔽されているか？

#### 責務の明確性
- [ ] 単一の明確な責務を表現しているか？
- [ ] その責務の境界が明確か？
- [ ] 責務外のことは含まれていないか？

#### ドメイン適合性
- [ ] ドメインエキスパートが使う用語と一致しているか？
- [ ] ビジネス概念を適切に表現しているか？
- [ ] 技術的詳細ではなくビジネス価値を表現しているか？

#### 一貫性
- [ ] 同じ概念には同じ名前を使っているか？
- [ ] 異なる概念には異なる名前を使っているか？
- [ ] プロジェクト全体で命名ルールが統一されているか？

#### 発見可能性
- [ ] 他の開発者が容易に見つけられるか？
- [ ] 推測可能な名前になっているか？
- [ ] 略語や暗号的な表現を避けているか？

### 2.5.5　実践的命名パターン

#### パターン1: レイヤー別命名

```csharp
// プレゼンテーション層
public class CustomerController        // ~Controller
public class OrderViewModel           // ~ViewModel
public class ProductDisplayModel      // ~DisplayModel

// ビジネス層
public class OrderProcessingService   // ~Service
public class PriceCalculationEngine   // ~Engine
public class InventoryManager         // ~Manager

// データ層
public class CustomerRepository       // ~Repository
public class OrderDataAccess         // ~DataAccess
public class ProductDao              // ~Dao (Data Access Object)
```

#### パターン2: 処理タイプ別命名

```csharp
// 生成・作成
public class OrderBuilder            // ~Builder
public class CustomerFactory         // ~Factory
public class ReportGenerator         // ~Generator

// 変換・処理
public class OrderProcessor          // ~Processor
public class DataTransformer         // ~Transformer
public class MessageHandler          // ~Handler

// 検証・判定
public class OrderValidator          // ~Validator
public class EligibilityChecker      // ~Checker
public class SecurityGuard           // ~Guard
```

#### パターン3: 状態・結果別命名

```csharp
// 結果クラス
public class ValidationResult        // ~Result
public class ProcessingOutcome       // ~Outcome
public class OperationStatus         // ~Status

// 設定クラス
public class DatabaseConfiguration   // ~Configuration
public class EmailSettings          // ~Settings
public class SecurityOptions        // ~Options
```

## まとめ

第2章では、命名がプログラミングにおける最も重要な活動の一つであることを学んだ。効果的な命名により、コードは「検証可能な設計モデル」となり、チーム全体でのコミュニケーションが向上する。

### 重要なポイント

1. **命名はモデリング**：名前を付けることで概念を確定し、境界を明確にする
2. **サービス指向**：利用者の視点で名前を決定する
3. **一貫性が重要**：プロジェクト全体で統一されたルールを適用する
4. **継続的改善**：命名は一度決めて終わりではなく、理解が深まるにつれて改善していく

次章では、この命名の技法を基盤として、「モデリングとしてのプログラミング」について詳しく学ぶ。プログラミングが単なる実装作業ではなく、現実世界をソフトウェアで表現するモデリング活動であることを理解していく。